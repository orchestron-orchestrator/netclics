import http
import json
import logging
import net
import netconf
import router_client
import time
import process
import xml

actor ContainerManager(proc_cap: process.ProcessCap, log_handler: logging.Handler):
    """Manages Docker containers for network devices"""

    # Set up logging
    logh = logging.Handler("ContainerManager")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    def start_container(platform: PlatformConfig, instance_id: str) -> str:
        """Start a Docker container for the given platform"""
        # Generate unique container name
        container_name = "netclics-%s-%s" % (platform.name.replace(" ", "-"), instance_id)

        # Build docker run command arguments
        # --name: container name
        # --rm: remove container when it stops
        # -p: publish ports (would map container ports to host ports)
        # Note: In production, we'd run in foreground to stop with our process
        # For now, just use a placeholder image since the actual startup is mocked
        # In a real implementation, we would handle the optional container_image properly
        docker_args = [
            "run",
            "--name", container_name,
            "--rm",
            "-d",  # Detached mode for now
            "placeholder-image"  # Temporary placeholder - not actually used since we don't run containers
        ]

        _log.info("Starting container", {"container_name": container_name, "platform": platform.name, "instance_id": instance_id})
        _log.debug("Docker command would be", {"command": "docker " + " ".join(docker_args)})

        # For now, just log the command we would run
        # In production, would execute: process.Process(proc_cap, "docker", docker_args, {})

        # Schedule health check
        after 2: _check_container_health(container_name, platform)

        return container_name

    def _check_container_health(container_name: str, platform: PlatformConfig):
        """Check if container is healthy and get its network info"""
        # In reality, would run: docker inspect <container_name>
        # This would be done with:
        # inspect_proc = process.Process(proc_cap, "docker", ["inspect", container_name], {})
        # Then parse the JSON output to get:
        # - Container state (running, health status)
        # - IP address from NetworkSettings.IPAddress
        # - Port mappings from NetworkSettings.Ports

        _log.debug("Checking container health", {"container_name": container_name, "platform": platform.name})
        # Would parse actual docker inspect output here

    def get_container_info(container_name: str) -> dict[str, str]:
        """Get container network information"""
        # In reality: docker inspect <container_name>
        # Returns mock data for now
        _log.debug("Getting container info", {"container_name": container_name})
        return {
            "ip": "172.17.0.10",
            "netconf_port": "32830",
            "ssh_port": "32822"
        }

    def stop_container(container_name: str):
        """Stop a Docker container"""
        # In reality, would run: docker stop <container_name>
        _log.info("Stopping container", {"container_name": container_name})
        # Since we use --rm, container will be removed automatically

actor DeviceInstance(auth: WorldCap, log_handler: logging.Handler, platform_name: str, platform: str,
                     container_id: str, ip_address: str,
                     netconf_port: int, ssh_port: int, instance_spec: ?InstanceSpec = None):
    """Actor representing a device instance that can process conversion requests"""
    var state = "starting"  # starting, ready, busy, stopping, error
    var current_request: ?ConvertRequest = None  # Currently processing request
    var started_at = 0  # Timestamp when started
    var last_used_at = 0  # Timestamp of last use

    # Set up logging
    logh = logging.Handler("DeviceInstance")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    def is_static_instance() -> bool:
        """Check if this is a static instance (vs dynamically created container)"""
        if instance_spec is not None:
            return True
        return False

    def get_state() -> str:
        return state

    def set_state(new_state: str):
        state = new_state

    def get_info() -> dict[str, ?value]:
        """Get device information for API responses"""
        instance_data = {
            "platform_name": platform_name,
            "platform": platform,
            "instance_id": container_id,
            "ip_address": ip_address,
            "state": state,
            "netconf_port": netconf_port,
            "ssh_port": ssh_port,
            "instance_type": "static" if is_static_instance() else "container"
        }
        if instance_spec is not None:
            desc = instance_spec.description
            if desc is not None:
                instance_data["description"] = desc
        return instance_data

    def _rollback_to_config(target_config: str, result_callback: action(str, bool) -> None):
        """Rollback device configuration to a previous state"""
        _log.info("DeviceInstance.rollback called", {"device": container_id})
        _log.debug("Target config length", {"device": container_id, "config_length": len(target_config)})

        state = "busy"

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            state = "ready"
            result_callback("No credentials available", False)
            return

        _log.info("Starting NETCONF rollback", {"username": username, "host": ip_address, "port": netconf_port})

        def on_connect(client: ?netconf.Client, error: ?Exception):
            if error is not None:
                _log.error("NETCONF rollback connection error", {"error": error})
                state = "ready"
                result_callback(f"NETCONF rollback connection error: {error}", False)
                return

            def on_edit_config_done(client: netconf.Client, response: ?xml.Node):
                _log.debug("Rollback edit-config response received")
                if response is not None:
                    response_xml = xml.encode(response)
                    _log.debug("Rollback edit-config response", {"response_xml": response_xml})

                    # Check for NETCONF errors in the response
                    if "<rpc-error>" in response_xml:
                        _log.error("Rollback edit-config failed with NETCONF error", {"response_xml": response_xml})
                        client.close()
                        state = "ready"
                        result_callback(f"NETCONF rollback edit-config error: {response_xml}", False)
                    elif "<ok/>" in response_xml or "<ok>" in response_xml:
                        _log.info("Rollback edit-config completed successfully")

                        # Now commit the rollback
                        def on_commit_done(client: netconf.Client, commit_response: ?xml.Node):
                            _log.debug("Rollback commit response received")
                            if commit_response is not None:
                                commit_xml = xml.encode(commit_response)
                                _log.debug("Rollback commit response", {"commit_xml": commit_xml})

                                if "<rpc-error>" in commit_xml:
                                    _log.error("Rollback commit failed with NETCONF error", {"commit_xml": commit_xml})
                                    client.close()
                                    state = "ready"
                                    result_callback(f"NETCONF rollback commit error: {commit_xml}", False)
                                elif "<ok/>" in commit_xml or "<ok>" in commit_xml:
                                    _log.info("Rollback commit completed successfully")
                                    client.close()
                                    state = "ready"
                                    result_callback("Configuration successfully rolled back", True)
                                else:
                                    _log.warning("Rollback commit response format unexpected", {"commit_xml": commit_xml})
                                    client.close()
                                    state = "ready"
                                    result_callback("Configuration rollback completed", True)
                            else:
                                _log.error("Rollback commit failed - received None response")
                                client.close()
                                state = "ready"
                                result_callback("Rollback commit operation failed", False)

                        _log.debug("Sending rollback commit request")
                        client.commit(on_commit_done)
                    else:
                        _log.warning("Rollback edit-config response format unexpected", {"response_xml": response_xml})
                        client.close()
                        state = "ready"
                        result_callback("Configuration rollback completed", True)
                else:
                    _log.error("Rollback edit-config failed - received None response")
                    client.close()
                    state = "ready"
                    result_callback("Rollback edit-config operation failed", False)

            if client is not None:
                # Client is guaranteed to be non-None here
                _log.info("NETCONF client connected successfully")
                _log.debug("Client capabilities", {"capabilities": str(client.get_capabilities())})

                # Apply the rollback configuration with default-operation=replace
                _log.debug("Sending rollback edit-config with default-operation=replace")
                # Use the rpc method directly to include default-operation=replace
                nc_nsdefs = [(None, "urn:ietf:params:xml:ns:netconf:base:1.0")]
                children = [
                    xml.Node("target", children=[xml.Node("candidate")]),
                    xml.Node("default-operation", text="replace"),
                    xml.Node("config", [("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], text=target_config)
                ]
                client.rpc(xml.Node("edit-config", nc_nsdefs, children=children), on_edit_config_done)
            else:
                _log.error("NETCONF rollback connection failed - no client")
                state = "ready"
                result_callback("NETCONF rollback connection failed", False)
                return

        # Create NETCONF client for rollback
        _log.info("Creating NETCONF client connection for rollback")
        netconf_client = netconf.Client(
            auth=auth,
            on_connect=on_connect,
            on_notif=None,
            address=ip_address,
            username=username,
            key=None,
            password=password,
            port=netconf_port,
            log_handler=log_handler
        )
        _log.info("NETCONF rollback client created, attempting connection")

    def convert(request: ConvertRequest, result_callback: action(str, bool) -> None):
        """Process a conversion request on this device"""
        _log.info("DeviceInstance.convert called", {"device": container_id, "input_format": request.format, "output_format": request.target_format})
        _log.debug("Input data", {"device": container_id, "input_data": request.input})

        state = "busy"
        current_request = request

        # Step 1: Get base configuration before applying changes
        # Always get NETCONF base config for rollback purposes
        def on_netconf_base_config_retrieved(netconf_base_config: str, netconf_base_success: bool):
            if netconf_base_success:
                _log.info("NETCONF base configuration retrieved successfully for rollback")

                # Step 1b: If target format is CLI, also get CLI base config for response
                def on_target_base_config_retrieved(target_base_config: str, target_base_success: bool):
                    if target_base_success:
                        _log.info("Target format base configuration retrieved successfully")

                        # Step 2: Apply input using appropriate input handler
                        def on_input_applied(success: bool, error_msg: ?str):
                            if success:
                                _log.info("Input applied successfully")

                                # Step 3: Retrieve final configuration using appropriate output handler
                                def on_final_config_retrieved(final_config: str, final_success: bool):
                                    if final_success:
                                        _log.info("Final configuration retrieved successfully")

                                        # Step 3.5: Get diff if target format is CLI
                                        def on_diff_retrieved(diff_text: str, diff_success: bool):
                                            # Step 4: Rollback to base configuration to clean up the device
                                            # Always use NETCONF base config for rollback
                                            def on_rollback_complete(rollback_result: str, rollback_success: bool):
                                                if rollback_success:
                                                    _log.info("Device successfully rolled back to clean state")
                                                else:
                                                    _log.warning("Rollback failed but conversion succeeded", {"rollback_result": rollback_result})

                                                # Return base, final configurations and diff
                                                # Use target format base config for response
                                                result_dict = {
                                                    "base_config": target_base_config,
                                                    "config": final_config,
                                                    "diff": diff_text if diff_success else ""
                                                }
                                                combined_result = json.encode(result_dict)
                                                state = "ready"
                                                current_request = None
                                                result_callback(combined_result, True)

                                            # Start rollback process
                                            extracted_config = extract_config_from_response(netconf_base_config)
                                            _log.info("Starting automatic rollback to clean device state using NETCONF")
                                            config_preview = extracted_config[:200] if len(extracted_config) > 200 else extracted_config
                                            _log.debug("Extracted config for rollback", {"config_preview": config_preview})
                                            _log.debug("About to call _rollback_to_config() method")
                                            _rollback_to_config(extracted_config, on_rollback_complete)

                                        # Extract just the configuration from the NETCONF base_config for rollback
                                        def extract_config_from_response(rpc_response: str) -> str:
                                            # Find the <configuration> element within the response
                                            config_start = rpc_response.find("<configuration")
                                            config_end = rpc_response.find("</configuration>") + len("</configuration>")
                                            if config_start != -1 and config_end != -1:
                                                config_xml = rpc_response[config_start:config_end]
                                                config_preview = config_xml[:300] if len(config_xml) > 300 else config_xml
                                                _log.debug("Original extracted config", {"config_preview": config_preview})

                                                # No need to add operation="replace" since we use default-operation=replace
                                                _log.debug("Using configuration as-is with default-operation=replace")
                                                return config_xml
                                            else:
                                                _log.warning("Could not extract configuration from response, using full response")
                                                return rpc_response

                                        # Get diff based on target format
                                        if request.target_format == "cli":
                                            _log.info("Getting CLI diff using compare rollback")
                                            _get_cli_diff(on_diff_retrieved)
                                        else:
                                            _log.info("NETCONF target format - skipping diff (not supported)")
                                            on_diff_retrieved("", True)  # Empty diff for NETCONF
                                    else:
                                        _log.error("Failed to retrieve final configuration", {"final_config": final_config})
                                        state = "ready"
                                        current_request = None
                                        result_callback(final_config, False)

                                # Get final configuration using utility functions (don't manage state)
                                if request.target_format == "cli":
                                    _get_cli_config(on_final_config_retrieved)
                                elif request.target_format == "netconf":
                                    _get_netconf_config(on_final_config_retrieved)
                                else:
                                    # For other formats, use the general handler
                                    _handle_output(request.target_format, on_final_config_retrieved)
                            else:
                                err_str: str = "Input application failed"
                                if error_msg is not None:
                                    err_str = error_msg
                                _log.error("Input application failed", {"error": err_str})
                                state = "ready"
                                current_request = None
                                result_callback(err_str, False)

                        _handle_input(request.format, request.input, on_input_applied)
                    else:
                        _log.error("Failed to retrieve target format base configuration", {"target_base_config": target_base_config})
                        state = "ready"
                        current_request = None
                        result_callback(target_base_config, False)

                # Get base config in target format for response (if different from NETCONF)
                if request.target_format == "netconf":
                    # Target format is NETCONF, so use the same config for both purposes
                    on_target_base_config_retrieved(netconf_base_config, netconf_base_success)
                else:
                    # Target format is different (CLI), so get it separately for response
                    _log.info("Getting base configuration in target format for response", {"target_format": request.target_format})
                    if request.target_format == "cli":
                        _get_cli_config(on_target_base_config_retrieved)
                    else:
                        # For other formats, use the general handler (this shouldn't happen currently)
                        _handle_output(request.target_format, on_target_base_config_retrieved)
            else:
                _log.error("Failed to retrieve NETCONF base configuration", {"netconf_base_config": netconf_base_config})
                state = "ready"
                current_request = None
                result_callback(netconf_base_config, False)

        # Start by always getting the NETCONF base configuration for rollback
        _log.info("Getting base configuration in NETCONF format for rollback")
        _get_netconf_config(on_netconf_base_config_retrieved)

    def _handle_input(input_format: str, input_data: str, callback: action(bool, ?str) -> None):
        """Apply input data using the appropriate input handler"""
        _log.info("Handling input format", {"input_format": input_format})

        if input_format == "netconf":
            _netconf_input(input_data, callback)
        elif input_format == "cli":
            _cli_input(input_data, callback)
        elif input_format == "restconf":
            # TODO: Implement RESTCONF input handler
            _log.error("RESTCONF input handler not yet implemented")
            callback(False, "RESTCONF input handler not implemented")
        else:
            _log.error("Unsupported input format", {"input_format": input_format})
            callback(False, f"Unsupported input format: {input_format}")

    def _handle_output(output_format: str, result_callback: action(str, bool) -> None):
        """Retrieve output data using the appropriate output handler"""
        _log.info("Handling output format", {"output_format": output_format})

        if output_format == "netconf":
            _netconf_output(result_callback)
        elif output_format == "cli":
            _cli_output(result_callback)
        elif output_format == "restconf":
            # TODO: Implement RESTCONF output handler
            _log.error("RESTCONF output handler not yet implemented")
            state = "ready"
            current_request = None
            result_callback("RESTCONF output handler not implemented", False)
        else:
            _log.error("Unsupported output format", {"output_format": output_format})
            state = "ready"
            current_request = None
            result_callback(f"Unsupported output format: {output_format}", False)

    def _netconf_input(input_data: str, callback: action(bool, ?str) -> None):
        """Apply configuration via NETCONF edit-config"""
        _log.info("NETCONF input handler: applying configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            callback(False, "No credentials available")
            return
        _log.info("Starting NETCONF input", {"username": username, "host": ip_address, "port": netconf_port})

        def on_connect(client: ?netconf.Client, error: ?Exception):
            if error is not None:
                _log.error("NETCONF connection error", {"error": error})
                callback(False, f"NETCONF connection error: {error}")
                return

            def on_edit_config_done(client: netconf.Client, response: ?xml.Node):
                _log.debug("Edit-config response received")
                if response is not None:
                    response_xml = xml.encode(response)
                    _log.debug("Edit-config response", {"response_xml": response_xml})

                    # Check for NETCONF errors in the response
                    if "<rpc-error>" in response_xml:
                        _log.error("Edit-config failed with NETCONF error", {"response_xml": response_xml})
                        client.close()
                        callback(False, f"NETCONF edit-config error: {response_xml}")
                    elif "<ok/>" in response_xml or "<ok>" in response_xml:
                        _log.info("Edit-config completed successfully")

                        # Now commit the candidate configuration
                        def on_commit_done(client: netconf.Client, commit_response: ?xml.Node):
                            _log.debug("Commit response received")
                            if commit_response is not None:
                                commit_xml = xml.encode(commit_response)
                                _log.debug("Commit response", {"commit_xml": commit_xml})

                                if "<rpc-error>" in commit_xml:
                                    _log.error("Commit failed with NETCONF error", {"commit_xml": commit_xml})
                                    client.close()
                                    callback(False, f"NETCONF commit error: {commit_xml}")
                                elif "<ok/>" in commit_xml or "<ok>" in commit_xml:
                                    _log.info("Commit completed successfully")
                                    client.close()
                                    callback(True, None)
                                else:
                                    _log.warning("Commit response format unexpected", {"commit_xml": commit_xml})
                                    client.close()
                                    callback(True, None)
                            else:
                                _log.error("Commit failed - received None response")
                                client.close()
                                callback(False, "Commit operation failed")

                        _log.debug("Sending commit request")
                        client.commit(on_commit_done)
                    else:
                        _log.warning("Edit-config response format unexpected", {"response_xml": response_xml})
                        # Assume success if no explicit error
                        client.close()
                        callback(True, None)
                else:
                    _log.error("Edit-config failed - received None response")
                    client.close()
                    callback(False, "Edit-config operation failed")

            if client is not None:
                _log.info("NETCONF client connected successfully")
                _log.debug("Client capabilities", {"capabilities": str(client.get_capabilities())})

                # Apply the input configuration
                _log.debug("Sending edit-config with input", {"input_data": input_data})
                # Try candidate datastore instead of running
                client.edit_config(input_data, on_edit_config_done, "candidate")
            else:
                _log.error("NETCONF connection failed - no client")
                callback(False, "NETCONF connection failed")
                return

        # Create NETCONF client
        _log.info("Creating NETCONF client connection", {"host": ip_address, "port": netconf_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password)})

        netconf_client = netconf.Client(
            auth=auth,
            on_connect=on_connect,
            on_notif=None,
            address=ip_address,
            username=username,
            key=None,
            password=password,
            port=netconf_port,
            log_handler=log_handler
        )
        _log.info("NETCONF client created, attempting connection")

    def _cli_input(input_data: str, callback: action(bool, ?str) -> None):
        """Apply CLI configuration via router_client"""
        _log.info("CLI input handler: applying CLI configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            callback(False, "No credentials available")
            return
        _log.info("Starting CLI input", {"username": username, "host": ip_address, "port": ssh_port})

        # Parse CLI commands from input data (split by newlines)
        cli_commands = []
        for line in input_data.split("\n"):
            line = line.strip()
            if line != "" and not line.startswith("#"):  # Skip empty lines and comments
                cli_commands.append(line)

        if not cli_commands:
            callback(False, "No valid CLI commands found in input")
            return

        _log.debug("Parsed CLI commands", {"commands": cli_commands, "count": len(cli_commands)})

        def on_success(response: str):
            _log.info("CLI configuration applied successfully")
            _log.debug("CLI success response", {"response": response})
            callback(True, None)

        def on_error(err: Exception, response: str):
            _log.error("CLI configuration failed", {"error": str(err), "response": response})
            callback(False, "CLI configuration error: " + str(err))

        # Create router client
        _log.info("Creating CLI client connection", {"host": ip_address, "port": ssh_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password) if password is not None else 0})

        client = router_client.Client(
            auth=auth,
            address=ip_address,
            username=username,
            password=password,
            port=ssh_port,
            device_type="juniper_junos",  # Specify JUNOS device type
            log_handler=log_handler
        )

        # Wait for connection and apply configuration
        def try_configure(attempt: int):
            if client.is_connected():
                _log.debug("CLI client connected, sending configuration commands")
                client.configure_and_commit(on_success, on_error, cli_commands)
            elif attempt < 10:  # Retry for up to 5 seconds (10 attempts * 500ms)
                _log.debug("CLI client not ready, retrying", {"attempt": attempt + 1})
                after 0.5: try_configure(attempt + 1)
            else:
                _log.error("CLI client failed to connect after retries")
                callback(False, "CLI client failed to connect within timeout")

        _log.debug("Waiting for CLI client to connect")
        after 0.1: try_configure(0)  # Start checking after 100ms

    def _get_netconf_config(callback: action(str, bool) -> None):
        """Utility function to get NETCONF config without managing conversion state"""
        _log.info("NETCONF config utility: retrieving configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            callback("No credentials available", False)
            return
        _log.info("Starting NETCONF config retrieval", {"username": username, "host": ip_address, "port": netconf_port})

        def on_connect(client: ?netconf.Client, error: ?Exception):
            if error is not None:
                _log.error("NETCONF connection error", {"error": error})
                callback(f"NETCONF connection error: {error}", False)
                return

            def on_get_config_done(client: netconf.Client, response: ?xml.Node):
                _log.debug("Get-config response received")
                if response is not None:
                    config_xml = xml.encode(response)
                    _log.debug("Get-config response", {"config_xml": config_xml})

                    # Check for NETCONF errors in the response
                    if "<rpc-error>" in config_xml:
                        _log.error("Get-config failed with NETCONF error", {"config_xml": config_xml})
                        client.close()
                        callback(f"NETCONF get-config error: {config_xml}", False)
                    else:
                        _log.info("Get-config completed successfully")
                        _log.info("Retrieved configuration", {"config_length": len(config_xml)})
                        _log.debug("Closing NETCONF connection")
                        client.close()
                        callback(config_xml, True)
                else:
                    _log.error("Get-config failed - received None response")
                    client.close()
                    callback("Get-config operation failed", False)

            if client is not None:
                _log.info("NETCONF utility client connected successfully")
                _log.debug("Client capabilities", {"capabilities": str(client.get_capabilities())})

                # Get the configuration
                _log.debug("Sending get-config request")
                client.get_config(on_get_config_done)
            else:
                _log.error("NETCONF connection failed - no client")
                callback("NETCONF connection failed", False)
                return

        # Create NETCONF client
        _log.info("Creating NETCONF utility client", {"host": ip_address, "port": netconf_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password)})

        netconf_client = netconf.Client(
            auth=auth,
            on_connect=on_connect,
            on_notif=None,
            address=ip_address,
            username=username,
            key=None,
            password=password,
            port=netconf_port,
            log_handler=log_handler
        )
        _log.info("NETCONF utility client created, attempting connection")

    def _get_cli_config(callback: action(str, bool) -> None):
        """Utility function to get CLI config without managing conversion state"""
        _log.info("CLI config utility: retrieving configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            callback("No credentials available for CLI config", False)
            return

        _log.info("Starting CLI config retrieval", {"username": username, "host": ip_address, "port": ssh_port})

        def on_cmd_complete(err: ?Exception, response: ?str):
            if err is not None:
                _log.error("CLI config retrieval failed", {"error": str(err)})
                callback("CLI config error: " + str(err), False)
            elif response is not None:
                _log.info("CLI config retrieved successfully")
                _log.debug("CLI config response", {"response_length": len(response)})
                callback(response, True)
            else:
                _log.error("CLI config failed - received None response")
                callback("CLI config failed", False)

        # Create router client
        _log.info("Creating CLI utility client", {"host": ip_address, "port": ssh_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password) if password is not None else 0})

        client = router_client.Client(
            auth=auth,
            address=ip_address,
            username=username,
            password=password,
            port=ssh_port,
            device_type="juniper_junos",  # Specify JUNOS device type
            log_handler=log_handler
        )

        # Wait for connection and get config
        def try_get_config(attempt: int):
            if client.is_connected():
                _log.debug("CLI utility client connected, sending show config command")
                client.cmd(on_cmd_complete, "show configuration")
            elif attempt < 10:  # Retry for up to 5 seconds (10 attempts * 500ms)
                _log.debug("CLI utility client not ready, retrying", {"attempt": attempt + 1})
                after 0.5: try_get_config(attempt + 1)
            else:
                _log.error("CLI utility client failed to connect after retries")
                callback("CLI utility client failed to connect within timeout", False)

        _log.debug("Waiting for CLI utility client to connect")
        after 0.1: try_get_config(0)  # Start checking after 100ms

    def _netconf_output(result_callback: action(str, bool) -> None):
        """Retrieve configuration via NETCONF get-config"""
        _log.info("NETCONF output handler: retrieving configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            state = "ready"
            current_request = None
            result_callback("No credentials available", False)
            return
        _log.info("Starting NETCONF output", {"username": username, "host": ip_address, "port": netconf_port})

        def on_connect(client: ?netconf.Client, error: ?Exception):
            if error is not None:
                _log.error("NETCONF connection error", {"error": error})
                _log.debug("Releasing device due to error")
                state = "ready"
                current_request = None
                result_callback(f"NETCONF connection error: {error}", False)
                return

            def on_get_config_done(client: netconf.Client, response: ?xml.Node):
                _log.debug("Get-config response received")
                if response is not None:
                    config_xml = xml.encode(response)
                    _log.debug("Get-config response", {"config_xml": config_xml})

                    # Check for NETCONF errors in the response
                    if "<rpc-error>" in config_xml:
                        _log.error("Get-config failed with NETCONF error", {"config_xml": config_xml})
                        client.close()
                        state = "ready"
                        current_request = None
                        result_callback(f"NETCONF get-config error: {config_xml}", False)
                    else:
                        _log.info("Get-config completed successfully")
                        _log.info("Retrieved configuration", {"config_length": len(config_xml)})
                        _log.info("Conversion completed successfully")

                        _log.debug("Closing NETCONF connection")
                        client.close()
                        _log.debug("Releasing device")
                        state = "ready"
                        current_request = None
                        result_callback(config_xml, True)
                else:
                    _log.error("Get-config failed - received None response")
                    client.close()
                    state = "ready"
                    current_request = None
                    result_callback("Get-config operation failed", False)

            if client is not None:
                _log.info("NETCONF client connected successfully")
                _log.debug("Client capabilities", {"capabilities": str(client.get_capabilities())})

                # Get the configuration
                _log.debug("Sending get-config request")
                client.get_config(on_get_config_done)
            else:
                _log.error("NETCONF connection failed - no client")
                state = "ready"
                current_request = None
                result_callback("NETCONF connection failed", False)
                return

        # Create NETCONF client
        _log.info("Creating NETCONF client connection", {"host": ip_address, "port": netconf_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password)})

        netconf_client = netconf.Client(
            auth=auth,
            on_connect=on_connect,
            on_notif=None,
            address=ip_address,
            username=username,
            key=None,
            password=password,
            port=netconf_port,
            log_handler=log_handler
        )
        _log.info("NETCONF client created, attempting connection")

    def _cli_output(result_callback: action(str, bool) -> None):
        """Retrieve configuration via CLI commands"""
        _log.info("CLI output handler: retrieving configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            state = "ready"
            current_request = None
            result_callback("No credentials available", False)
            return

        _log.info("Starting CLI output", {"username": username, "host": ip_address, "port": ssh_port})

        def on_success(response: str):
            _log.info("CLI show configuration completed successfully")
            _log.debug("CLI response", {"response_length": len(response)})
            state = "ready"
            current_request = None
            result_callback(response, True)

        def on_error(error: Exception, response: str):
            _log.error("CLI show configuration failed", {"error": str(error), "response": response})
            state = "ready"
            current_request = None
            result_callback("CLI show configuration error: " + str(error), False)

        # Create router client
        _log.info("Creating CLI client connection", {"host": ip_address, "port": ssh_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password) if password is not None else 0})

        client = router_client.Client(
            auth=auth,
            address=ip_address,
            username=username,
            password=password,
            port=ssh_port,
            device_type="juniper_junos",  # Specify JUNOS device type
            log_handler=log_handler
        )

        # Use cmd method for show commands instead of configure_and_commit
        def on_cmd_complete(err: ?Exception, response: ?str):
            if err is not None:
                _log.error("CLI show configuration failed", {"error": str(err)})
                state = "ready"
                current_request = None
                result_callback("CLI show configuration error: " + str(err), False)
            elif response is not None:
                _log.info("CLI show configuration completed successfully")
                _log.debug("CLI response", {"response_length": len(response)})
                state = "ready"
                current_request = None
                result_callback(response, True)
            else:
                _log.error("CLI show configuration failed - received None response")
                state = "ready"
                current_request = None
                result_callback("CLI show configuration failed", False)

        # Wait for connection and get configuration
        def try_show_config(attempt: int):
            if client.is_connected():
                _log.debug("CLI client connected, sending show configuration command")
                client.cmd(on_cmd_complete, "show configuration")
            elif attempt < 10:  # Retry for up to 5 seconds (10 attempts * 500ms)
                _log.debug("CLI client not ready, retrying", {"attempt": attempt + 1})
                after 0.5: try_show_config(attempt + 1)
            else:
                _log.error("CLI client failed to connect after retries")
                state = "ready"
                current_request = None
                result_callback("CLI client failed to connect within timeout", False)

        _log.debug("Waiting for CLI client to connect")
        after 0.1: try_show_config(0)  # Start checking after 100ms

    def _get_cli_diff(result_callback: action(str, bool) -> None):
        """Get CLI diff using 'show configuration | compare rollback 1'"""
        _log.info("CLI diff handler: getting configuration differences")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            result_callback("No credentials available for CLI diff", False)
            return

        _log.info("Starting CLI diff retrieval", {"username": username, "host": ip_address, "port": ssh_port})

        def on_cmd_complete(err: ?Exception, response: ?str):
            if err is not None:
                _log.error("CLI diff command failed", {"error": str(err)})
                result_callback("CLI diff error: " + str(err), False)
            elif response is not None:
                _log.info("CLI diff retrieved successfully")
                _log.debug("CLI diff response", {"response_length": len(response)})
                result_callback(response, True)
            else:
                _log.error("CLI diff failed - received None response")
                result_callback("CLI diff failed", False)

        # Create router client
        _log.info("Creating CLI client for diff", {"host": ip_address, "port": ssh_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password) if password is not None else 0})

        client = router_client.Client(
            auth=auth,
            address=ip_address,
            username=username,
            password=password,
            port=ssh_port,
            device_type="juniper_junos",  # Specify JUNOS device type
            log_handler=log_handler
        )

        # Wait for connection and get diff
        def try_get_diff(attempt: int):
            if client.is_connected():
                _log.debug("CLI client connected, sending diff command")
                client.cmd(on_cmd_complete, "show configuration | compare rollback 1")
            elif attempt < 10:  # Retry for up to 5 seconds (10 attempts * 500ms)
                _log.debug("CLI client not ready for diff, retrying", {"attempt": attempt + 1})
                after 0.5: try_get_diff(attempt + 1)
            else:
                _log.error("CLI client failed to connect for diff after retries")
                result_callback("CLI client failed to connect for diff within timeout", False)

        _log.debug("Waiting for CLI client to connect for diff")
        after 0.1: try_get_diff(0)  # Start checking after 100ms

    def _get_credentials() -> ?(str, str):
        """Get device credentials, returns (username, password) tuple or None"""
        _log.debug("Checking device credentials")
        if instance_spec is not None:
            _log.debug("InstanceSpec found")
            _username = instance_spec.username
            _password = instance_spec.password
            _log.debug("Checking username and password")
            if _username is not None and _password is not None:
                username = _username
                password = _password
                _log.info("Credentials found", {"username": username})
                return (username, password)
            else:
                _log.error("Missing username or password for device", {"device": container_id, "username": str(_username), "password_set": str(True if _password is not None else False)})
                return None
        else:
            _log.error("No InstanceSpec available for device", {"device": container_id})
            return None

actor DeviceManager(config: SystemConfig, container_mgr: ContainerManager, auth: WorldCap, log_handler: logging.Handler):
    """Manages device lifecycle and state transitions"""
    var instances = []  # DeviceInstance actors
    var instance_info = []  # Cached info for API responses
    var pending_requests = []  # Requests waiting for a device
    var next_instance_id = 1

    def count_instances(platform_name: str, state: ?str = None) -> int:
        """Count instances for a platform, optionally filtered by state"""
        # Simplified for now - just return length of instance_info
        return len(instance_info)

    def initialize_static_instances(platform: PlatformConfig):
        """Initialize static instances for a platform"""
        for spec in platform.instances:
            device = DeviceInstance(
                auth=auth,
                log_handler=log_handler,
                platform_name=platform.name,
                platform=platform.platform,
                container_id=spec.id,
                ip_address=spec.host,
                netconf_port=spec.netconf_port,
                ssh_port=spec.ssh_port,
                instance_spec=spec
            )
            device.set_state("ready")  # Specified instances are assumed to be ready
            instances.append(device)

            # Add to instance_info for API responses
            instance_data = {
                "platform_name": platform.name,
                "platform": platform.platform,
                "instance_id": spec.id,
                "ip_address": spec.host,
                "state": "ready",
                "netconf_port": spec.netconf_port,
                "ssh_port": spec.ssh_port,
                "instance_type": "static"
            }
            desc = spec.description
            if desc is not None:
                instance_data["description"] = desc
            instance_info.append(instance_data)

    def get_device_for_request(platform_name: str) -> ?DeviceInstance:
        """Get or create a device for a request"""
        # Simplified for now - just return first ready device
        for i in range(len(instances)):
            device = instances[i]
            if device.get_state() == "ready":
                return device
        return None

    def start_device(platform: PlatformConfig) -> ?DeviceInstance:
        """Start a new device instance (only for dynamically managed platforms)"""
        if platform.uses_static_instances():
            return None

        instance_id = str(next_instance_id)
        next_instance_id += 1

        # Create a placeholder device in starting state
        device = DeviceInstance(
            auth=auth,
            log_handler=log_handler,
            platform_name="dynamic-platform",  # Hardcoded for now
            platform="dynamic",  # Hardcoded for now
            container_id=f"starting-{instance_id}",
            ip_address="pending",
            netconf_port=830,  # Use default for now
            ssh_port=22  # Use default for now
        )
        device.set_state("starting")
        instances.append(device)

        return device

    def initialize_min_instances():
        """Initialize specified instances and start minimum number of container instances for each platform"""
        for platform in config.platforms:
            # First, initialize any static instances
            initialize_static_instances(platform)

            # Then start minimum container instances if needed
            if not platform.uses_static_instances() and platform.min_instances > 0:
                current_count = count_instances(platform.name)
                to_start = platform.min_instances - current_count
                for i in range(to_start):
                    start_device(platform)

    def get_instance_info() -> list[dict[str, ?value]]:
        """Get instance info for API responses"""
        return instance_info

    def get_config() -> SystemConfig:
        """Get system configuration"""
        return config


class InstanceSpec(object):
    """Specification for a static instance (physical device, VM, or pre-existing container)"""
    def __init__(self, id: str, host: str, netconf_port: int = 830,
                 ssh_port: int = 22, restconf_port: int = 443, username: ?str = None, password: ?str = None,
                 private_key_path: ?str = None, description: ?str = None):
        self.id = id
        self.host = host  # IP address or hostname
        self.netconf_port = netconf_port
        self.ssh_port = ssh_port
        self.restconf_port = restconf_port
        self.username = username
        self.password = password
        self.private_key_path = private_key_path
        self.description = description

class PlatformConfig(object):
    name: str
    platform: str
    container_image: ?str
    min_instances: int
    max_instances: int
    startup_time_seconds: int
    idle_timeout_seconds: int
    netconf_port: int
    ssh_port: int
    restconf_port: int
    instances: list[InstanceSpec]
    active_instances: int
    available_instances: int

    def __init__(self, name: str, platform: str, container_image: ?str = None,
                 min_instances: int = 0, max_instances: int = 10,
                 startup_time_seconds: int = 60, idle_timeout_seconds: int = 300,
                 netconf_port: int = 830, ssh_port: int = 22, restconf_port: int = 443,
                 instances: ?list[InstanceSpec] = None):
        self.name = name
        self.platform = platform
        self.container_image = container_image  # Optional for physical devices
        self.min_instances = min_instances
        self.max_instances = max_instances
        self.startup_time_seconds = startup_time_seconds  # Expected container startup time
        self.idle_timeout_seconds = idle_timeout_seconds  # When to shut down idle containers
        self.netconf_port = netconf_port  # NETCONF port inside container
        self.ssh_port = ssh_port  # SSH/CLI port inside container
        self.restconf_port = restconf_port  # RESTCONF port inside container
        if instances is not None and len(instances) > 0:
            self.instances = instances
        else:
            self.instances = []
        # Runtime state (managed by Director)
        self.active_instances = 0
        self.available_instances = 0

    def uses_static_instances(self) -> bool:
        """Returns True if this platform uses static instances rather than dynamic scaling"""
        return len(self.instances) > 0

class SystemConfig(object):
    def __init__(self, platforms: list[PlatformConfig]):
        self.platforms = platforms

    def get_platform(self, name: str) -> ?PlatformConfig:
        for p in self.platforms:
            if p.name == name:
                return p
        return None

class ConvertRequest(object):
    def __init__(self, input: str, format: str, target_format: str, platform: str, cb: ?action(str) -> None = None):
        self.input = input
        self.format = format
        self.target_format = target_format
        self.platform = platform
        self.platform_version = None  # For now, always None
        self.cb = cb  # Optional callback for async processing

    @staticmethod
    def from_json(data: dict[str, ?value]):
        # Get all required fields first
        if "input" not in data:
            raise ValueError("Missing required field: input")
        if "format" not in data:
            raise ValueError("Missing required field: format")
        if "target_format" not in data:
            raise ValueError("Missing required field: target_format")
        if "platform" not in data:
            raise ValueError("Missing required field: platform")

        input_val = data["input"]
        format_val = data["format"]
        target_format_val = data["target_format"]
        platform_val = data["platform"]

        # Type check all at once
        if isinstance(input_val, str) and isinstance(format_val, str) and isinstance(target_format_val, str) and isinstance(platform_val, str):
            return ConvertRequest(input_val, format_val, target_format_val, platform_val, None)
        else:
            raise ValueError("All fields must be strings")

actor Director(auth: WorldCap, proc_cap: process.ProcessCap, log_handler: logging.Handler):
    var device_manager: ?DeviceManager = None
    logh = logging.Handler("Director")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    def set_config(conf: SystemConfig):
        container_mgr = ContainerManager(proc_cap, log_handler)
        dm = DeviceManager(conf, container_mgr, auth, log_handler)
        dm.initialize_min_instances()
        device_manager = dm
        _log.info("Director initialized")


    def convert(request: ConvertRequest, callback: action(str, bool) -> None):
        """Process a conversion request"""
        _log.info("Director.convert called", {"input_format": request.format, "output_format": request.target_format, "platform": request.platform, "input_length": len(request.input)})

        dm = device_manager
        if dm is not None:
            _log.info("DeviceManager found, requesting device")
            device = dm.get_device_for_request(request.platform)
            if device is not None:
                _log.info("Device acquired successfully")

                # Dispatch conversion request to the device
                _log.info("Dispatching conversion request to device")
                device.convert(request, callback)
            else:
                _log.error("No device available for platform", {"platform": request.platform})
                callback("No device available for %s" % request.platform, False)
        else:
            _log.error("Director not initialized - no DeviceManager")
            callback("Director not initialized", False)


    def cli2xml(conf: str, cb):
        raise NotImplementedError()

    def xml2cli(conf: str):
        raise NotImplementedError()

    def get_instances() -> list[dict[str, ?value]]:
        """Get list of all instances for API response"""
        dm = device_manager
        if dm is not None:
            return dm.get_instance_info()
        else:
            return []

    def get_platforms() -> list[dict[str, ?value]]:
        """Get list of all configured platforms for API response"""
        platforms_data: list[dict[str, ?value]] = []
        dm = device_manager
        if dm is not None:
            config = dm.get_config()
            instance_info = dm.get_instance_info()
            for platform in config.platforms:
                # Count current instances - simplified for now
                total_instances = len(platform.instances) if platform.uses_static_instances() else 0
                available_instances = total_instances  # Simplified - assume all static instances are ready

                platform_data = {
                    "name": platform.name,
                    "platform": platform.platform,
                    "scaling_type": "static" if platform.uses_static_instances() else "dynamic",
                    "total_instances": total_instances,
                    "available_instances": available_instances
                }

                # Add static instances info if applicable
                if platform.uses_static_instances():
                    instances_info = []
                    for spec in platform.instances:
                        spec_info = {
                            "id": spec.id,
                            "host": spec.host,
                            "netconf_port": spec.netconf_port,
                            "ssh_port": spec.ssh_port
                        }
                        desc = spec.description
                        if desc is not None:
                            spec_info["description"] = desc
                        instances_info.append(spec_info)
                    platform_data["instances"] = instances_info
                else:
                    # For dynamic platforms, show scaling configuration
                    platform_data["min_instances"] = platform.min_instances
                    platform_data["max_instances"] = platform.max_instances

                platforms_data.append(platform_data)
        return platforms_data

actor WebServ(listen_cap: net.TCPListenCap, port, director, log_handler: logging.Handler):
    logh = logging.Handler("WebServ")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    def _on_http_accept(server):
        server.cb_install(_on_http_server_request, _on_http_server_error)

    def _on_http_server_request(server, request, respond):
        _log.info("HTTP request received", {"method": request.method, "path": request.path})
        if request.path == "/api/v1/convert" and request.method == "POST":
            _log.info("Processing conversion request")
            try:
                body_str = request.body.decode()
                _log.debug("Request body", {"body": body_str})
                body_dict = json.decode(body_str)
                _log.debug("Parsed JSON", {"body_dict": str(body_dict)})

                # Parse the request using the from_json method
                convert_req = ConvertRequest.from_json(body_dict)
                _log.info("ConvertRequest created", {"input_format": convert_req.format, "output_format": convert_req.target_format, "platform": convert_req.platform})

                # Define callback for when conversion completes
                def on_conversion_done(result: str, success: bool):
                    _log.debug("Conversion completed, preparing HTTP response")
                    if success:
                        _log.info("Conversion successful", {"result_length": len(result)})

                        # Try to parse the result as JSON (base_config + config format)
                        try:
                            result_dict = json.decode(result)
                            if isinstance(result_dict, dict) and "base_config" in result_dict and "config" in result_dict:
                                # New format with before/after configs and diff
                                response = {
                                    "success": True,
                                    "base_config": result_dict["base_config"],
                                    "config": result_dict["config"],
                                    "platform": convert_req.platform,
                                    "platform_version": "1.0"
                                }
                                # Add diff field if it exists in result_dict
                                if "diff" in result_dict:
                                    response["diff"] = result_dict["diff"]
                                else:
                                    response["diff"] = ""
                            else:
                                # Fallback to old format
                                response = {
                                    "success": True,
                                    "output": result,
                                    "platform": convert_req.platform,
                                    "platform_version": "1.0"
                                }
                        except Exception:
                            # If JSON parsing fails, use old format
                            response = {
                                "success": True,
                                "output": result,
                                "platform": convert_req.platform,
                                "platform_version": "1.0"
                            }
                    else:
                        _log.error("Conversion failed", {"result": result})
                        response = {
                            "success": False,
                            "error": result,
                            "platform": convert_req.platform
                        }
                    response_str = json.encode(response)
                    _log.debug("Sending HTTP response", {"response_length": len(response_str)})
                    respond(200, {"Content-Type": "application/json"}, response_str)

                # Use Director's conversion logic with callback
                _log.debug("Calling Director.convert")
                director.convert(convert_req, on_conversion_done)
            except Exception as e:
                error_dict = {"success": False, "error": str(e)}
                error_str = json.encode(error_dict)
                respond(400, {"Content-Type": "application/json"}, error_str)
        # GET /api/v1/instances - List all running instances
        elif request.path == "/api/v1/instances" and request.method == "GET":
            # Get actual instances from director
            instances_data = director.get_instances()

            response = {
                "instances": instances_data,
                "total": len(instances_data)
            }
            respond(200, {"Content-Type": "application/json"}, json.encode(response))

        # GET /api/v1/platforms - List configured platforms
        elif request.path == "/api/v1/platforms" and request.method == "GET":
            # Get actual platforms from director
            platforms_data = director.get_platforms()

            response = {
                "platforms": platforms_data,
                "total": len(platforms_data)
            }
            respond(200, {"Content-Type": "application/json"}, json.encode(response))

        else:
            respond(404, {}, json.encode({"error": "Not found"}))

    def _on_http_server_error(server, error):
        pass

    server = http.Listener(listen_cap, "0.0.0.0", port, _on_http_accept)


def get_default_config() -> SystemConfig:
    return SystemConfig([
        # Juniper cRPD platform - dynamically managed containers
#        PlatformConfig(
#            name="crpd",
#            version="24.4R1.9",
#            container_image="ghcr.io/orchestron-orchestrator/respnet/crpd:24.4R1.9",
#            min_instances=1,
#            max_instances=3
#        ),
        # Local cRPD static instance
        PlatformConfig(
            name="crpd 24.4R1.9-local",
            platform="junos",
            instances=[
                InstanceSpec(
                    id="local-crpd",
                    host="127.0.0.1",
                    netconf_port=32781,
                    ssh_port=32780,
                    restconf_port=32774,
                    username="clab",
                    password="clab@123",
                    description="Local cRPD instance"
                )
            ]
        ),
        # Example platform with static instances (could be physical devices, VMs, etc.)
#        PlatformConfig(
#            name="junos",
#            version="21.4R1",
#            static_instances=[
#                InstanceSpec(
#                    instance_id="lab-router-1",
#                    host="192.168.1.10",
#                    netconf_port=830,
#                    ssh_port=22,
#                    username="admin",
#                    description="Lab router #1"
#                ),
#                InstanceSpec(
#                    instance_id="lab-router-2",
#                    host="192.168.1.11",
#                    netconf_port=830,
#                    ssh_port=22,
#                    username="admin",
#                    description="Lab router #2"
#                )
#            ]
#        )
    ])

actor main(env: Env):
    listen_cap = net.TCPListenCap(net.TCPCap(net.NetCap(env.cap)))
    proc_cap = process.ProcessCap(env.cap)
    port = 8080

    # Load configuration
    config = get_default_config()
    # Create logging handler
    log_handler = logging.Handler(None)
    log_handler.add_sink(logging.StdoutSink())
    log_handler.set_output_level(logging.TRACE)  # Set maximum debugging for SSH/NETCONF

    # Create logger for main
    logh = logging.Handler("main")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    _log.info("Loaded platform configurations", {"platform_count": len(config.platforms)})

    director = Director(env.cap, proc_cap, log_handler)
    director.set_config(config)
    webs = WebServ(listen_cap, port, director, log_handler)
    _log.info("NETCLICS started", {"port": port})
