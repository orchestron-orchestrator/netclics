import http
import json
import logging
import net
import netconf
import router_client
import time
import process
import xml
import yang
import yang.gen3
import yang.gdata
import yang.schema
import schema_getter

actor ContainerManager(proc_cap: process.ProcessCap, log_handler: logging.Handler):
    """Manages Docker containers for network devices"""

    # Set up logging
    logh = logging.Handler("ContainerManager")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    def start_container(platform: PlatformConfig, instance_id: str) -> str:
        """Start a Docker container for the given platform"""
        # Generate unique container name
        container_name = "netclics-%s-%s" % (platform.name.replace(" ", "-"), instance_id)

        # Build docker run command arguments
        # --name: container name
        # --rm: remove container when it stops
        # -p: publish ports (would map container ports to host ports)
        # Note: In production, we'd run in foreground to stop with our process
        # For now, just use a placeholder image since the actual startup is mocked
        # In a real implementation, we would handle the optional container_image properly
        docker_args = [
            "run",
            "--name", container_name,
            "--rm",
            "-d",  # Detached mode for now
            "placeholder-image"  # Temporary placeholder - not actually used since we don't run containers
        ]

        _log.info("Starting container", {"container_name": container_name, "platform": platform.name, "instance_id": instance_id})
        _log.debug("Docker command would be", {"command": "docker " + " ".join(docker_args)})

        # For now, just log the command we would run
        # In production, would execute: process.Process(proc_cap, "docker", docker_args, {})

        # Schedule health check
        after 2: _check_container_health(container_name, platform)

        return container_name

    def _check_container_health(container_name: str, platform: PlatformConfig):
        """Check if container is healthy and get its network info"""
        # In reality, would run: docker inspect <container_name>
        # This would be done with:
        # inspect_proc = process.Process(proc_cap, "docker", ["inspect", container_name], {})
        # Then parse the JSON output to get:
        # - Container state (running, health status)
        # - IP address from NetworkSettings.IPAddress
        # - Port mappings from NetworkSettings.Ports

        _log.debug("Checking container health", {"container_name": container_name, "platform": platform.name})
        # Would parse actual docker inspect output here

    def get_container_info(container_name: str) -> dict[str, str]:
        """Get container network information"""
        # In reality: docker inspect <container_name>
        # Returns mock data for now
        _log.debug("Getting container info", {"container_name": container_name})
        return {
            "ip": "172.17.0.10",
            "netconf_port": "32830",
            "ssh_port": "32822"
        }

    def stop_container(container_name: str):
        """Stop a Docker container"""
        # In reality, would run: docker stop <container_name>
        _log.info("Stopping container", {"container_name": container_name})
        # Since we use --rm, container will be removed automatically

actor DeviceInstance(auth: WorldCap, log_handler: logging.Handler, platform_name: str, platform: str,
                     container_id: str, ip_address: str,
                     netconf_port: int, ssh_port: int, instance_spec: ?InstanceSpec = None):
    """Actor representing a device instance that can process conversion requests"""
    var state = "starting"  # starting, ready, busy, stopping, error
    var current_request: ?ConvertRequest = None  # Currently processing request
    var started_at = 0  # Timestamp when started
    var last_used_at = 0  # Timestamp of last use

    # Schema storage
    var compiled_schema: ?yang.schema.DRoot = None  # Compiled YANG schema
    var schema_list: list[str] = []  # Raw YANG schema strings
    var schema_ready = False  # Flag indicating schemas are ready

    # Storage for parsed configs during conversion
    var base_gdata: ?yang.gdata.Node = None
    var final_gdata: ?yang.gdata.Node = None
    var rollback_xml: ?str = None  # Store raw XML for rollback

    # Set up logging
    logh = logging.Handler("DeviceInstance")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    def is_static_instance() -> bool:
        """Check if this is a static instance (vs dynamically created container)"""
        if instance_spec is not None:
            return True
        return False

    def get_state() -> str:
        return state

    def set_state(new_state: str):
        state = new_state

    def get_info() -> dict[str, ?value]:
        """Get device information for API responses"""
        instance_data = {
            "platform_name": platform_name,
            "platform": platform,
            "instance_id": container_id,
            "ip_address": ip_address,
            "state": state,
            "netconf_port": netconf_port,
            "ssh_port": ssh_port,
            "instance_type": "static" if is_static_instance() else "container"
        }
        if instance_spec is not None:
            desc = instance_spec.description
            if desc is not None:
                instance_data["description"] = desc
        return instance_data

    def _rollback_to_config(target_config: str, result_callback: action(str, bool) -> None):
        """Rollback device configuration to a previous state"""
        _log.info("DeviceInstance.rollback called", {"device": container_id})
        _log.debug("Target config length", {"device": container_id, "config_length": len(target_config)})

        state = "busy"

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            state = "ready"
            result_callback("No credentials available", False)
            return

        _log.info("Starting NETCONF rollback", {"username": username, "host": ip_address, "port": netconf_port})

        def on_connect(client: ?netconf.Client, error: ?Exception):
            if error is not None:
                _log.error("NETCONF rollback connection error", {"error": error})
                state = "ready"
                result_callback(f"NETCONF rollback connection error: {error}", False)
                return

            def on_edit_config_done(client: netconf.Client, response: ?xml.Node, error: ?netconf.NetconfError):
                _log.debug("Rollback edit-config response received")
                if error is not None:
                    _log.error("Rollback edit-config failed with NETCONF error", {"error": error})
                    client.close()
                    state = "ready"
                    result_callback("NETCONF rollback edit-config error: {error}", False)
                else:
                    _log.info("Rollback edit-config completed successfully")

                    # Now commit the rollback
                    def on_commit_done(client: netconf.Client, commit_error: ?netconf.NetconfError):
                        _log.debug("Rollback commit response received")
                        if commit_error is not None:
                            _log.error("Rollback commit failed with NETCONF error", {"error": commit_error})
                            client.close()
                            state = "ready"
                            result_callback("NETCONF rollback commit error: {commit_error}", False)
                        else:
                            _log.info("Rollback commit completed successfully")
                            client.close()
                            state = "ready"
                            result_callback("Configuration successfully rolled back", True)

                    _log.debug("Sending rollback commit request")
                    client.commit(on_commit_done)

            if client is not None:
                # Client is guaranteed to be non-None here
                _log.info("NETCONF client connected successfully")
                _log.debug("Client capabilities", {"capabilities": str(client.get_capabilities())})

                # Apply the rollback configuration with default-operation=replace
                _log.debug("Sending rollback edit-config with default-operation=replace")
                # Use the rpc method directly to include default-operation=replace
                nc_nsdefs = [(None, "urn:ietf:params:xml:ns:netconf:base:1.0")]
                # Merge the RPC data with target-config
                # Decode the target_config XML string into xml.Node objects to preserve
                # structure. Direct assignment to text attribute of the <config> node
                # would escape special characters, breaking the XML. We wrap the config
                # in <data> tags for parsing because the config is likely to
                # contain multiple top-level nodes, then use only the children.
                # TODO: this is not very efficient as we decode the XML string to
                # xml.Node only to encode the RPC document again right away.
                target_config_xml = xml.decode("<data>{target_config}</data>")

                children = [
                    xml.Node("target", children=[xml.Node("candidate")]),
                    xml.Node("default-operation", text="replace"),
                    xml.Node("config", [("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], children=target_config_xml.children)
                ]
                client.rpc(xml.Node("edit-config", nc_nsdefs, children=children), on_edit_config_done)
            else:
                _log.error("NETCONF rollback connection failed - no client")
                state = "ready"
                result_callback("NETCONF rollback connection failed", False)
                return

        # Create NETCONF client for rollback
        _log.info("Creating NETCONF client connection for rollback")
        netconf_client = netconf.Client(
            auth=auth,
            on_connect=on_connect,
            on_notif=None,
            address=ip_address,
            username=username,
            key=None,
            password=password,
            port=netconf_port,
            log_handler=log_handler,
            skip_host_key_check=True
        )
        _log.info("NETCONF rollback client created, attempting connection")

    def convert(request: ConvertRequest, result_callback: action(str, bool) -> None):
        """Process a conversion request on this device"""
        _log.info("DeviceInstance.convert called", {"device": container_id, "input_format": request.format, "output_format": request.target_format})
        _log.debug("Input data", {"device": container_id, "input_data": request.input})

        state = "busy"
        current_request = request

        # Reset gdata storage for new conversion
        base_gdata = None
        final_gdata = None
        rollback_xml = None

        # Helper function to format gdata output based on target format
        def format_gdata_output(gdata: yang.gdata.Node, target_format: str) -> str:
            """Format parsed gdata to the requested output format"""
            if target_format == "json":
                return gdata.to_json()
            elif target_format == "acton-gdata":
                return gdata.prsrc()
            elif target_format == "acton-adata":
                if compiled_schema is not None:
                    return yang.gen3.pradata(compiled_schema, gdata, loose=True)
                else:
                    _log.warning("No compiled schema for adata conversion, using gdata")
                    return gdata.prsrc()
            elif target_format in ["netconf", "xml"]:
                return gdata.to_xmlstr(name="configuration", pretty=True)
            else:
                _log.warning("Unknown target format, using XML", {"target_format": target_format})
                return gdata.to_xmlstr(name="configuration", pretty=True)

        # Helper function for processing with base config
        def process_with_base(target_base_config: str):
                    # Step 2: Apply input using appropriate input handler
                    def on_input_applied(success: bool, error_msg: ?str):
                        if success:
                            _log.info("Input applied successfully")

                            # Step 3: Retrieve final configuration
                            def process_with_final(final_config: str):
                                    _log.info("Final configuration formatted successfully")

                                    # Step 3.5: Get diff
                                    def on_diff_retrieved(diff_text: str, diff_success: bool):
                                        # Step 4: Rollback to base configuration to clean up the device
                                        def on_rollback_complete(rollback_result: str, rollback_success: bool):
                                            if rollback_success:
                                                _log.info("Device successfully rolled back to clean state")
                                            else:
                                                _log.warning("Rollback failed but conversion succeeded", {"rollback_result": rollback_result})

                                            # Return base, final configurations and diff
                                            result_dict = {
                                                "base_config": target_base_config,
                                                "config": final_config,
                                                "diff": diff_text if diff_success else ""
                                            }
                                            combined_result = json.encode(result_dict)
                                            state = "ready"
                                            current_request = None
                                            # Clean up gdata storage
                                            base_gdata = None
                                            final_gdata = None
                                            rollback_xml = None
                                            result_callback(combined_result, True)

                                        # Start rollback process using saved XML
                                        if rollback_xml is not None:
                                            extracted_config = extract_config_from_xml(rollback_xml)
                                            _log.info("Starting automatic rollback to clean device state using NETCONF")
                                            config_preview = extracted_config[:200] if len(extracted_config) > 200 else extracted_config
                                            _log.debug("Extracted config for rollback", {"config_preview": config_preview})
                                            _rollback_to_config(extracted_config, on_rollback_complete)
                                        else:
                                            _log.error("No rollback XML available")
                                            on_rollback_complete("No rollback XML available", False)

                                    # Extract just the configuration element from raw XML
                                    def extract_config_from_xml(raw_xml: str) -> str:
                                        # The raw_xml is already just the <data> element content
                                        # Find the <configuration> element within it
                                        config_start = raw_xml.find("<configuration")
                                        config_end = raw_xml.find("</configuration>") + len("</configuration>")
                                        if config_start != -1 and config_end != -1:
                                            return raw_xml[config_start:config_end]
                                        else:
                                            _log.warning("Could not find configuration element, using full XML")
                                            return raw_xml

                                    # Get diff based on target format
                                    if request.target_format == "cli":
                                        _log.info("Getting CLI diff using compare rollback")
                                        _get_cli_diff(on_diff_retrieved)
                                    elif base_gdata is not None and final_gdata is not None:
                                        # Use gdata diff for schema-aware formats
                                        _log.info("Computing gdata-based diff")
                                        diff_text = _compute_gdata_diff()
                                        on_diff_retrieved(diff_text, True)
                                    else:
                                        _log.info("Diff not available")
                                        on_diff_retrieved("", True)  # Empty diff


                            def on_final_config_retrieved(config_tuple: (str, ?yang.gdata.Node), final_success: bool):
                                if final_success:
                                    final_raw_xml, final_parsed_gdata = config_tuple
                                    if final_parsed_gdata is not None:
                                        _log.info("Final configuration retrieved and parsed successfully")

                                        # Store final gdata for diff
                                        final_gdata = final_parsed_gdata

                                        # Format final config for response
                                        final_config = ""
                                        if request.target_format == "cli":
                                            # CLI needs special handling
                                            def on_cli_final_retrieved(cli_config: str, cli_success: bool):
                                                if cli_success:
                                                    process_with_final(cli_config)
                                                else:
                                                    _log.error("Failed to get CLI final config")
                                                    state = "ready"
                                                    current_request = None
                                                    result_callback("Failed to get CLI final config", False)
                                            _get_cli_config(on_cli_final_retrieved)
                                        else:
                                            # Format gdata for response
                                            final_config = format_gdata_output(final_parsed_gdata, request.target_format)
                                            process_with_final(final_config)
                                    else:
                                        _log.error("Failed to parse final configuration")
                                        state = "ready"
                                        current_request = None
                                        result_callback("Failed to parse final configuration", False)
                                else:
                                    _log.error("Failed to retrieve final configuration")
                                    state = "ready"
                                    current_request = None
                                    result_callback("Failed to retrieve final configuration", False)

                            # Get final configuration using new unified function
                            _get_netconf_config_parsed(on_final_config_retrieved)
                        else:
                            err_str: str = "Input application failed"
                            if error_msg is not None:
                                err_str = error_msg
                            _log.error("Input application failed", {"error": err_str})
                            state = "ready"
                            current_request = None
                            result_callback(err_str, False)

                    _handle_input(request.format, request.input, on_input_applied)

        # Step 1: Get base configuration before applying changes
        def on_base_config_retrieved(config_tuple: (str, ?yang.gdata.Node), success: bool):
            if success:
                raw_xml, parsed_gdata = config_tuple
                if parsed_gdata is not None:
                    _log.info("Base configuration retrieved and parsed successfully")

                    # Store for later use
                    rollback_xml = raw_xml  # Save raw XML for rollback
                    base_gdata = parsed_gdata  # Save parsed data for diff

                    # Format base config for response
                    target_base_config = ""
                    if request.target_format == "cli":
                        # CLI needs special handling
                        def on_cli_base_retrieved(cli_config: str, cli_success: bool):
                            if cli_success:
                                process_with_base(cli_config)
                            else:
                                _log.error("Failed to get CLI base config")
                                state = "ready"
                                current_request = None
                                result_callback("Failed to get CLI base config", False)
                        _get_cli_config(on_cli_base_retrieved)
                    else:
                        # Format gdata for response
                        target_base_config = format_gdata_output(parsed_gdata, request.target_format)
                        process_with_base(target_base_config)
                else:
                    _log.error("Failed to parse base configuration")
                    state = "ready"
                    current_request = None
                    result_callback("Failed to parse base configuration", False)
            else:
                _log.error("Failed to retrieve base configuration")
                state = "ready"
                current_request = None
                result_callback("Failed to retrieve base configuration", False)

        # Start by getting base configuration using the new unified function
        _log.info("Getting base configuration")
        _get_netconf_config_parsed(on_base_config_retrieved)

    def _handle_input(input_format: str, input_data: str, callback: action(bool, ?str) -> None):
        """Apply input data using the appropriate input handler"""
        _log.info("Handling input format", {"input_format": input_format})

        if input_format == "netconf":
            _netconf_input(input_data, callback)
        elif input_format == "cli":
            _cli_input(input_data, callback)
        elif input_format == "restconf":
            # TODO: Implement RESTCONF input handler
            _log.error("RESTCONF input handler not yet implemented")
            callback(False, "RESTCONF input handler not implemented")
        else:
            _log.error("Unsupported input format", {"input_format": input_format})
            callback(False, f"Unsupported input format: {input_format}")

    def _netconf_input(input_data: str, callback: action(bool, ?str) -> None):
        """Apply configuration via NETCONF edit-config"""
        _log.info("NETCONF input handler: applying configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            callback(False, "No credentials available")
            return
        _log.info("Starting NETCONF input", {"username": username, "host": ip_address, "port": netconf_port})

        def on_connect(client: ?netconf.Client, error: ?Exception):
            if error is not None:
                _log.error("NETCONF connection error", {"error": error})
                callback(False, f"NETCONF connection error: {error}")
                return

            def on_edit_config_done(client: netconf.Client, error: ?netconf.NetconfError):
                _log.debug("Edit-config response received")
                if error is not None:
                    _log.error("Edit-config failed with NETCONF error", {"error": error})
                    client.close()
                    callback(False, "NETCONF edit-config error: {error}")
                else:
                    _log.info("Edit-config completed successfully")

                    # Now commit the candidate configuration
                    def on_commit_done(client: netconf.Client, commit_error: ?netconf.NetconfError):
                        _log.debug("Commit response received")
                        if commit_error is not None:
                            _log.error("Commit failed with NETCONF error", {"error": commit_error})
                            client.close()
                            callback(False, "NETCONF commit error: {commit_error}")
                        else:
                            _log.info("Commit completed successfully")
                            client.close()
                            callback(True, None)

                    _log.debug("Sending commit request")
                    client.commit(on_commit_done)

            if client is not None:
                _log.info("NETCONF client connected successfully")
                _log.debug("Client capabilities", {"capabilities": str(client.get_capabilities())})

                # Apply the input configuration
                _log.debug("Sending edit-config with input", {"input_data": input_data})
                # Try candidate datastore instead of running
                client.edit_config(input_data, on_edit_config_done, "candidate")
            else:
                _log.error("NETCONF connection failed - no client")
                callback(False, "NETCONF connection failed")
                return

        # Create NETCONF client
        _log.info("Creating NETCONF client connection", {"host": ip_address, "port": netconf_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password)})

        netconf_client = netconf.Client(
            auth=auth,
            on_connect=on_connect,
            on_notif=None,
            address=ip_address,
            username=username,
            key=None,
            password=password,
            port=netconf_port,
            log_handler=log_handler,
            skip_host_key_check=True
        )
        _log.info("NETCONF client created, attempting connection")

    def _cli_input(input_data: str, callback: action(bool, ?str) -> None):
        """Apply CLI configuration via router_client"""
        _log.info("CLI input handler: applying CLI configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            callback(False, "No credentials available")
            return
        _log.info("Starting CLI input", {"username": username, "host": ip_address, "port": ssh_port})

        # Parse CLI commands from input data (split by newlines)
        cli_commands = []
        for line in input_data.split("\n"):
            line = line.strip()
            if line != "" and not line.startswith("#"):  # Skip empty lines and comments
                cli_commands.append(line)

        if not cli_commands:
            callback(False, "No valid CLI commands found in input")
            return

        _log.debug("Parsed CLI commands", {"commands": cli_commands, "count": len(cli_commands)})

        def on_success(response: str):
            _log.info("CLI configuration applied successfully")
            _log.debug("CLI success response", {"response": response})
            callback(True, None)

        def on_error(err: Exception, response: str):
            _log.error("CLI configuration failed", {"error": str(err), "response": response})
            callback(False, "CLI configuration error: " + str(err))

        # Create router client
        _log.info("Creating CLI client connection", {"host": ip_address, "port": ssh_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password) if password is not None else 0})

        client = router_client.Client(
            auth=auth,
            address=ip_address,
            username=username,
            password=password,
            port=ssh_port,
            device_type="juniper_junos",  # Specify JUNOS device type
            log_handler=log_handler
        )

        # Wait for connection and apply configuration
        def try_configure(attempt: int):
            if client.is_connected():
                _log.debug("CLI client connected, sending configuration commands")
                client.configure_and_commit(on_success, on_error, cli_commands)
            elif attempt < 10:  # Retry for up to 5 seconds (10 attempts * 500ms)
                _log.debug("CLI client not ready, retrying", {"attempt": attempt + 1})
                after 0.5: try_configure(attempt + 1)
            else:
                _log.error("CLI client failed to connect after retries")
                callback(False, "CLI client failed to connect within timeout")

        _log.debug("Waiting for CLI client to connect")
        after 0.1: try_configure(0)  # Start checking after 100ms

    def _get_cli_config(callback: action(str, bool) -> None):
        """Utility function to get CLI config without managing conversion state"""
        _log.info("CLI config utility: retrieving configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            callback("No credentials available for CLI config", False)
            return

        _log.info("Starting CLI config retrieval", {"username": username, "host": ip_address, "port": ssh_port})

        def on_cmd_complete(err: ?Exception, response: ?str):
            if err is not None:
                _log.error("CLI config retrieval failed", {"error": str(err)})
                callback("CLI config error: " + str(err), False)
            elif response is not None:
                _log.info("CLI config retrieved successfully")
                _log.debug("CLI config response", {"response_length": len(response)})
                callback(response, True)
            else:
                _log.error("CLI config failed - received None response")
                callback("CLI config failed", False)

        # Create router client
        _log.info("Creating CLI utility client", {"host": ip_address, "port": ssh_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password) if password is not None else 0})

        client = router_client.Client(
            auth=auth,
            address=ip_address,
            username=username,
            password=password,
            port=ssh_port,
            device_type="juniper_junos",  # Specify JUNOS device type
            log_handler=log_handler
        )

        # Wait for connection and get config
        def try_get_config(attempt: int):
            if client.is_connected():
                _log.debug("CLI utility client connected, sending show config command")
                client.cmd(on_cmd_complete, "show configuration")
            elif attempt < 10:  # Retry for up to 5 seconds (10 attempts * 500ms)
                _log.debug("CLI utility client not ready, retrying", {"attempt": attempt + 1})
                after 0.5: try_get_config(attempt + 1)
            else:
                _log.error("CLI utility client failed to connect after retries")
                callback("CLI utility client failed to connect within timeout", False)

        _log.debug("Waiting for CLI utility client to connect")
        after 0.1: try_get_config(0)  # Start checking after 100ms

    def _get_netconf_config_parsed(result_callback: action((str, ?yang.gdata.Node), bool) -> None):
        """Get NETCONF config and parse it with schemas

        Returns a tuple of (raw_xml, parsed_gdata) to the callback.
        Fails if parsing fails - we cannot proceed without parsed data.
        """
        _log.info("Getting NETCONF config with parsing")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            result_callback(("", None), False)
            return

        _log.info("Starting NETCONF retrieval", {"username": username, "host": ip_address, "port": netconf_port})

        def on_connect(client: ?netconf.Client, error: ?Exception):
            if error is not None:
                _log.error("NETCONF connection error", {"error": error})
                result_callback(("", None), False)
                return

            def on_get_config_done(client: netconf.Client, response: ?xml.Node, error: ?netconf.NetconfError):
                _log.debug("Get-config response received")
                if error is not None:
                    _log.error("Get-config failed with NETCONF error", {"error": error})
                    client.close()
                    result_callback(("", None), False)
                elif response is not None:
                    # Extract the <data> element from the RPC reply
                    data_node: ?xml.Node = None
                    for child in response.children:
                        if child.tag == "data":
                            data_node = child
                            break

                    if data_node is not None:
                        raw_xml = xml.encode(data_node)
                        _log.debug("Got raw XML", {"length": len(raw_xml)})

                        # Parse with schemas - this is required for conversion
                        if compiled_schema is not None:
                            try:
                                _log.info("Parsing XML with gen3 schemas")
                                parsed_gdata = yang.gen3.from_xml(compiled_schema, data_node, loose=True)
                                _log.info("Successfully parsed to gdata")

                                # Close connection and return results
                                client.close()
                                result_callback((raw_xml, parsed_gdata), True)
                            except Exception as e:
                                _log.error("Failed to parse with gen3 - cannot proceed", {"error": str(e)})
                                client.close()
                                result_callback(("", None), False)
                        else:
                            _log.error("No compiled schema available - cannot proceed with conversion")
                            client.close()
                            result_callback(("", None), False)
                    else:
                        _log.error("No data element in get-config response")
                        client.close()
                        result_callback(("", None), False)
                else:
                    _log.error("Get-config failed - received None response")
                    client.close()
                    result_callback(("", None), False)

            if client is not None:
                _log.info("NETCONF client connected successfully")
                _log.debug("Client capabilities", {"capabilities": str(client.get_capabilities())})
                client.get_config(on_get_config_done)
            else:
                _log.error("NETCONF connection failed - no client")
                result_callback(("", None), False)
                return

        # Create NETCONF client
        _log.info("Creating NETCONF client", {"host": ip_address, "port": netconf_port, "username": username})

        netconf_client = netconf.Client(
            auth=auth,
            on_connect=on_connect,
            on_notif=None,
            address=ip_address,
            username=username,
            key=None,
            password=password,
            port=netconf_port,
            log_handler=log_handler,
            skip_host_key_check=True
        )

    def _cli_output(result_callback: action(str, bool) -> None):
        """Retrieve configuration via CLI commands"""
        _log.info("CLI output handler: retrieving configuration")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            state = "ready"
            current_request = None
            result_callback("No credentials available", False)
            return

        _log.info("Starting CLI output", {"username": username, "host": ip_address, "port": ssh_port})

        def on_success(response: str):
            _log.info("CLI show configuration completed successfully")
            _log.debug("CLI response", {"response_length": len(response)})
            state = "ready"
            current_request = None
            result_callback(response, True)

        def on_error(error: Exception, response: str):
            _log.error("CLI show configuration failed", {"error": str(error), "response": response})
            state = "ready"
            current_request = None
            result_callback("CLI show configuration error: " + str(error), False)

        # Create router client
        _log.info("Creating CLI client connection", {"host": ip_address, "port": ssh_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password) if password is not None else 0})

        client = router_client.Client(
            auth=auth,
            address=ip_address,
            username=username,
            password=password,
            port=ssh_port,
            device_type="juniper_junos",  # Specify JUNOS device type
            log_handler=log_handler
        )

        # Use cmd method for show commands instead of configure_and_commit
        def on_cmd_complete(err: ?Exception, response: ?str):
            if err is not None:
                _log.error("CLI show configuration failed", {"error": str(err)})
                state = "ready"
                current_request = None
                result_callback("CLI show configuration error: " + str(err), False)
            elif response is not None:
                _log.info("CLI show configuration completed successfully")
                _log.debug("CLI response", {"response_length": len(response)})
                state = "ready"
                current_request = None
                result_callback(response, True)
            else:
                _log.error("CLI show configuration failed - received None response")
                state = "ready"
                current_request = None
                result_callback("CLI show configuration failed", False)

        # Wait for connection and get configuration
        def try_show_config(attempt: int):
            if client.is_connected():
                _log.debug("CLI client connected, sending show configuration command")
                client.cmd(on_cmd_complete, "show configuration")
            elif attempt < 10:  # Retry for up to 5 seconds (10 attempts * 500ms)
                _log.debug("CLI client not ready, retrying", {"attempt": attempt + 1})
                after 0.5: try_show_config(attempt + 1)
            else:
                _log.error("CLI client failed to connect after retries")
                state = "ready"
                current_request = None
                result_callback("CLI client failed to connect within timeout", False)

        _log.debug("Waiting for CLI client to connect")
        after 0.1: try_show_config(0)  # Start checking after 100ms

    def _get_cli_diff(result_callback: action(str, bool) -> None):
        """Get CLI diff using 'show configuration | compare rollback 1'"""
        _log.info("CLI diff handler: getting configuration differences")

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            result_callback("No credentials available for CLI diff", False)
            return

        _log.info("Starting CLI diff retrieval", {"username": username, "host": ip_address, "port": ssh_port})

        def on_cmd_complete(err: ?Exception, response: ?str):
            if err is not None:
                _log.error("CLI diff command failed", {"error": str(err)})
                result_callback("CLI diff error: " + str(err), False)
            elif response is not None:
                _log.info("CLI diff retrieved successfully")
                _log.debug("CLI diff response", {"response_length": len(response)})
                result_callback(response, True)
            else:
                _log.error("CLI diff failed - received None response")
                result_callback("CLI diff failed", False)

        # Create router client
        _log.info("Creating CLI client for diff", {"host": ip_address, "port": ssh_port, "username": username})
        _log.debug("Password masked", {"password_length": len(password) if password is not None else 0})

        client = router_client.Client(
            auth=auth,
            address=ip_address,
            username=username,
            password=password,
            port=ssh_port,
            device_type="juniper_junos",  # Specify JUNOS device type
            log_handler=log_handler
        )

        # Wait for connection and get diff
        def try_get_diff(attempt: int):
            if client.is_connected():
                _log.debug("CLI client connected, sending diff command")
                client.cmd(on_cmd_complete, "show configuration | compare rollback 1")
            elif attempt < 10:  # Retry for up to 5 seconds (10 attempts * 500ms)
                _log.debug("CLI client not ready for diff, retrying", {"attempt": attempt + 1})
                after 0.5: try_get_diff(attempt + 1)
            else:
                _log.error("CLI client failed to connect for diff after retries")
                result_callback("CLI client failed to connect for diff within timeout", False)

        _log.debug("Waiting for CLI client to connect for diff")
        after 0.1: try_get_diff(0)  # Start checking after 100ms

    def _compute_gdata_diff() -> str:
        """Compute diff between base_gdata and final_gdata"""
        if base_gdata is not None and final_gdata is not None:
            try:
                # Use yang.gdata.diff for semantic diff
                diff_result = yang.gdata.diff(base_gdata, final_gdata)

                if diff_result is not None:
                    # Convert diff to appropriate format based on target_format
                    if current_request is not None:
                        target_format = current_request.target_format
                        if target_format == "json":
                            return diff_result.to_json()
                        elif target_format == "acton-gdata":
                            return diff_result.prsrc()
                        elif target_format == "acton-adata":
                            # Convert diff to adata format if schema is available
                            if compiled_schema is not None:
                                return yang.gen3.pradata(compiled_schema, diff_result, loose=True)
                            else:
                                _log.warning("No compiled schema for adata diff conversion, using prsrc")
                                return diff_result.prsrc()
                        elif target_format in ["netconf", "xml"]:
                            # For XML formats, return the diff as XML string
                            return diff_result.to_xmlstr()
                        else:
                            # Default to prsrc format for unknown formats
                            _log.warning("Unknown target format for diff, using prsrc", {"target_format": target_format})
                            return diff_result.prsrc()
                    else:
                        return diff_result.prsrc()
                else:
                    _log.info("No differences found between base and final configs")
                    return "No configuration changes"
            except Exception as e:
                _log.error("Failed to compute gdata diff", {"error": str(e)})
                return ""
        else:
            _log.warning("Cannot compute gdata diff - missing base or final gdata")
            return ""

    def _get_credentials() -> ?(str, str):
        """Get device credentials, returns (username, password) tuple or None"""
        _log.debug("Checking device credentials")
        if instance_spec is not None:
            _log.debug("InstanceSpec found")
            _username = instance_spec.username
            _password = instance_spec.password
            _log.debug("Checking username and password")
            if _username is not None and _password is not None:
                username = _username
                password = _password
                _log.info("Credentials found", {"username": username})
                return (username, password)
            else:
                _log.error("Missing username or password for device", {"device": container_id, "username": str(_username), "password_set": str(True if _password is not None else False)})
                return None
        else:
            _log.error("No InstanceSpec available for device", {"device": container_id})
            return None

    def configure_rfc_compliance():
        """Configure the device for RFC/YANG compliant NETCONF operation (Juniper-specific)"""
        _log.info("Configuring Juniper device for RFC/YANG compliance", {"device": container_id})

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            _log.error("No credentials available for RFC compliance configuration")
            return

        def on_connect(client: netconf.Client, error: ?Exception):
            if error is not None:
                _log.error("Failed to connect for RFC compliance configuration", {"error": error})
                return

            _log.info("Connected for RFC compliance configuration")

            # Configuration to enable RFC-compliant and YANG-compliant modes
            config_xml = """
            <configuration>
                <system>
                    <services>
                        <netconf>
                            <rfc-compliant/>
                            <yang-compliant/>
                        </netconf>
                    </services>
                </system>
            </configuration>
            """

            def on_edit_config_done(c: netconf.Client, error: ?netconf.NetconfError):
                if error is not None:
                    _log.error("Failed to configure RFC compliance", {"error": error.error_message})
                    c.close()
                else:
                    _log.info("Successfully configured RFC/YANG compliance")
                    # Commit the configuration
                    c.commit(on_commit_done)

            def on_commit_done(c: netconf.Client, error: ?netconf.NetconfError):
                if error is not None:
                    _log.error("Failed to commit RFC compliance configuration", {"error": error.error_message})
                else:
                    _log.info("RFC/YANG compliance configuration committed")
                c.close()

            # Parse the config XML
            try:
                client.edit_config(config_xml, on_edit_config_done, "candidate")
            except Exception as e:
                _log.error("Failed to parse RFC compliance config", {"error": str(e)})
                client.close()

        # Create NETCONF client for RFC compliance configuration
        _log.info("Creating NETCONF client for RFC compliance configuration")
        netconf_client = netconf.Client(
            auth=auth,
            on_connect=on_connect,
            on_notif=None,
            address=ip_address,
            username=username,
            key=None,
            password=password,
            port=netconf_port,
            log_handler=log_handler,
            skip_host_key_check=True
        )

    def initialize_schemas():
        """Initialize schemas by downloading them from the device and compiling them"""
        _log.info("Initializing YANG schemas for device", {"device": container_id})

        # Get credentials
        creds = _get_credentials()
        if creds is not None:
            username, password = creds
        else:
            _log.error("No credentials available for schema initialization")
            state = "error"
            return

        def on_connect(client: netconf.Client, error: ?Exception):
            if error is not None:
                _log.error("Failed to connect for schema initialization", {"error": error})
                state = "error"
                return

            _log.info("Connected to device for schema initialization")

            # Create SchemaGetter actor
            sg = schema_getter.SchemaGetter(client, log_handler)

            # Callback for each schema download
            def on_schema_download(current_index: int, total_schemas: int, schema: (identifier: ?str, namespace: ?str, version: ?str, format: ?str), schema_data: ?str):
                if schema_data is not None:
                    schema_identifier = schema.identifier
                    if schema_identifier is not None:
                        # Skip junos-rpc schemas as they're not needed, and also don't compile :/
                        if schema_identifier.startswith("junos-rpc"):
                            return
                        _log.debug("Downloaded schema", {"identifier": schema_identifier, "index": current_index + 1, "total": total_schemas})
                        schema_list.append(schema_data)

            # Callback when all schemas are complete
            def on_schemas_complete(error: ?netconf.NetconfError):
                if error is not None:
                    _log.error("Error during schema download", {"error": error})
                    # Continue anyway - device can work without schemas

                _log.info("All schemas downloaded", {"count": len(schema_list)})

                # Compile the schemas
                try:
                    compiled_schema = yang.compile(schema_list)
                    _log.info("Successfully compiled YANG schemas")
                    schema_ready = True
                except Exception as e:
                    _log.error("Failed to compile schemas", {"error": e})
                    compiled_schema = None
                    schema_ready = False

                # Close the NETCONF connection
                client.close()

                # Set state to ready regardless of schema compilation result
                # (device can still work without schemas for basic operations)
                state = "ready"
                _log.info("Device initialization complete", {"device": container_id, "schemas_compiled": schema_ready})

            # Start downloading all schemas
            sg.download(on_schema_download, on_schemas_complete, "all")

        # Create NETCONF client
        _log.info("Creating NETCONF client for schema initialization", {"host": ip_address, "port": netconf_port})

        netconf_client = netconf.Client(
            auth=auth,
            on_connect=on_connect,
            on_notif=None,
            address=ip_address,
            username=username,
            key=None,
            password=password,
            port=netconf_port,
            log_handler=log_handler,
            skip_host_key_check=True
        )

actor DeviceManager(config: SystemConfig, container_mgr: ContainerManager, auth: WorldCap, log_handler: logging.Handler):
    """Manages device lifecycle and state transitions"""
    var instances = []  # DeviceInstance actors
    var instance_info = []  # Cached info for API responses
    var pending_requests = []  # Requests waiting for a device
    var next_instance_id = 1

    def count_instances(platform_name: str, state: ?str = None) -> int:
        """Count instances for a platform, optionally filtered by state"""
        # Simplified for now - just return length of instance_info
        return len(instance_info)

    def initialize_static_instances(platform: PlatformConfig):
        """Initialize static instances for a platform"""
        for spec in platform.instances:
            device = DeviceInstance(
                auth=auth,
                log_handler=log_handler,
                platform_name=platform.name,
                platform=platform.platform,
                container_id=spec.id,
                ip_address=spec.host,
                netconf_port=spec.netconf_port,
                ssh_port=spec.ssh_port,
                instance_spec=spec
            )

            # For Juniper platforms, configure RFC compliance first
            if platform.platform == "junos":
                device.configure_rfc_compliance()

            # Initialize schemas on device startup
            device.initialize_schemas()
            instances.append(device)

            # Add to instance_info for API responses
            instance_data = {
                "platform_name": platform.name,
                "platform": platform.platform,
                "instance_id": spec.id,
                "ip_address": spec.host,
                "state": "ready",
                "netconf_port": spec.netconf_port,
                "ssh_port": spec.ssh_port,
                "instance_type": "static"
            }
            desc = spec.description
            if desc is not None:
                instance_data["description"] = desc
            instance_info.append(instance_data)

    def get_device_for_request(platform_name: str) -> ?DeviceInstance:
        """Get or create a device for a request"""
        # Simplified for now - just return first ready device
        for i in range(len(instances)):
            device = instances[i]
            if device.get_state() == "ready":
                return device
        return None

    def start_device(platform: PlatformConfig) -> ?DeviceInstance:
        """Start a new device instance (only for dynamically managed platforms)"""
        if platform.uses_static_instances():
            return None

        instance_id = str(next_instance_id)
        next_instance_id += 1

        # Create a placeholder device in starting state
        device = DeviceInstance(
            auth=auth,
            log_handler=log_handler,
            platform_name="dynamic-platform",  # Hardcoded for now
            platform="dynamic",  # Hardcoded for now
            container_id=f"starting-{instance_id}",
            ip_address="pending",
            netconf_port=830,  # Use default for now
            ssh_port=22  # Use default for now
        )
        device.set_state("starting")
        instances.append(device)

        return device

    def initialize_min_instances():
        """Initialize specified instances and start minimum number of container instances for each platform"""
        for platform in config.platforms:
            # First, initialize any static instances
            initialize_static_instances(platform)

            # Then start minimum container instances if needed
            if not platform.uses_static_instances() and platform.min_instances > 0:
                current_count = count_instances(platform.name)
                to_start = platform.min_instances - current_count
                for i in range(to_start):
                    start_device(platform)

    def get_instance_info() -> list[dict[str, ?value]]:
        """Get instance info for API responses"""
        return instance_info

    def get_config() -> SystemConfig:
        """Get system configuration"""
        return config


class InstanceSpec(object):
    """Specification for a static instance (physical device, VM, or pre-existing container)"""
    def __init__(self, id: str, host: str, netconf_port: int = 830,
                 ssh_port: int = 22, restconf_port: int = 443, username: ?str = None, password: ?str = None,
                 private_key_path: ?str = None, description: ?str = None):
        self.id = id
        self.host = host  # IP address or hostname
        self.netconf_port = netconf_port
        self.ssh_port = ssh_port
        self.restconf_port = restconf_port
        self.username = username
        self.password = password
        self.private_key_path = private_key_path
        self.description = description

class PlatformConfig(object):
    name: str
    platform: str
    container_image: ?str
    min_instances: int
    max_instances: int
    startup_time_seconds: int
    idle_timeout_seconds: int
    netconf_port: int
    ssh_port: int
    restconf_port: int
    instances: list[InstanceSpec]
    active_instances: int
    available_instances: int

    def __init__(self, name: str, platform: str, container_image: ?str = None,
                 min_instances: int = 0, max_instances: int = 10,
                 startup_time_seconds: int = 60, idle_timeout_seconds: int = 300,
                 netconf_port: int = 830, ssh_port: int = 22, restconf_port: int = 443,
                 instances: ?list[InstanceSpec] = None):
        self.name = name
        self.platform = platform
        self.container_image = container_image  # Optional for physical devices
        self.min_instances = min_instances
        self.max_instances = max_instances
        self.startup_time_seconds = startup_time_seconds  # Expected container startup time
        self.idle_timeout_seconds = idle_timeout_seconds  # When to shut down idle containers
        self.netconf_port = netconf_port  # NETCONF port inside container
        self.ssh_port = ssh_port  # SSH/CLI port inside container
        self.restconf_port = restconf_port  # RESTCONF port inside container
        if instances is not None and len(instances) > 0:
            self.instances = instances
        else:
            self.instances = []
        # Runtime state (managed by Director)
        self.active_instances = 0
        self.available_instances = 0

    def uses_static_instances(self) -> bool:
        """Returns True if this platform uses static instances rather than dynamic scaling"""
        return len(self.instances) > 0

class SystemConfig(object):
    def __init__(self, platforms: list[PlatformConfig]):
        self.platforms = platforms

    def get_platform(self, name: str) -> ?PlatformConfig:
        for p in self.platforms:
            if p.name == name:
                return p
        return None

class ConvertRequest(object):
    def __init__(self, input: str, format: str, target_format: str, platform: str, cb: ?action(str) -> None = None):
        self.input = input
        self.format = format
        self.target_format = target_format
        self.platform = platform
        self.platform_version = None  # For now, always None
        self.cb = cb  # Optional callback for async processing

    @staticmethod
    def from_json(data: dict[str, ?value]):
        # Get all required fields first
        if "input" not in data:
            raise ValueError("Missing required field: input")
        if "format" not in data:
            raise ValueError("Missing required field: format")
        if "target_format" not in data:
            raise ValueError("Missing required field: target_format")
        if "platform" not in data:
            raise ValueError("Missing required field: platform")

        input_val = data["input"]
        format_val = data["format"]
        target_format_val = data["target_format"]
        platform_val = data["platform"]

        # Type check all at once
        if isinstance(input_val, str) and isinstance(format_val, str) and isinstance(target_format_val, str) and isinstance(platform_val, str):
            return ConvertRequest(input_val, format_val, target_format_val, platform_val, None)
        else:
            raise ValueError("All fields must be strings")

actor Director(auth: WorldCap, proc_cap: process.ProcessCap, log_handler: logging.Handler):
    var device_manager: ?DeviceManager = None
    logh = logging.Handler("Director")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    def set_config(conf: SystemConfig):
        container_mgr = ContainerManager(proc_cap, log_handler)
        dm = DeviceManager(conf, container_mgr, auth, log_handler)
        dm.initialize_min_instances()
        device_manager = dm
        _log.info("Director initialized")


    def convert(request: ConvertRequest, callback: action(str, bool) -> None):
        """Process a conversion request"""
        _log.info("Director.convert called", {"input_format": request.format, "output_format": request.target_format, "platform": request.platform, "input_length": len(request.input)})

        dm = device_manager
        if dm is not None:
            _log.info("DeviceManager found, requesting device")
            device = dm.get_device_for_request(request.platform)
            if device is not None:
                _log.info("Device acquired successfully")

                # Dispatch conversion request to the device
                _log.info("Dispatching conversion request to device")
                device.convert(request, callback)
            else:
                _log.error("No device available for platform", {"platform": request.platform})
                callback("No device available for %s" % request.platform, False)
        else:
            _log.error("Director not initialized - no DeviceManager")
            callback("Director not initialized", False)


    def cli2xml(conf: str, cb):
        raise NotImplementedError()

    def xml2cli(conf: str):
        raise NotImplementedError()

    def get_instances() -> list[dict[str, ?value]]:
        """Get list of all instances for API response"""
        dm = device_manager
        if dm is not None:
            return dm.get_instance_info()
        else:
            return []

    def get_platforms() -> list[dict[str, ?value]]:
        """Get list of all configured platforms for API response"""
        platforms_data: list[dict[str, ?value]] = []
        dm = device_manager
        if dm is not None:
            config = dm.get_config()
            instance_info = dm.get_instance_info()
            for platform in config.platforms:
                # Count current instances - simplified for now
                total_instances = len(platform.instances) if platform.uses_static_instances() else 0
                available_instances = total_instances  # Simplified - assume all static instances are ready

                platform_data = {
                    "name": platform.name,
                    "platform": platform.platform,
                    "scaling_type": "static" if platform.uses_static_instances() else "dynamic",
                    "total_instances": total_instances,
                    "available_instances": available_instances
                }

                # Add static instances info if applicable
                if platform.uses_static_instances():
                    instances_info = []
                    for spec in platform.instances:
                        spec_info = {
                            "id": spec.id,
                            "host": spec.host,
                            "netconf_port": spec.netconf_port,
                            "ssh_port": spec.ssh_port
                        }
                        desc = spec.description
                        if desc is not None:
                            spec_info["description"] = desc
                        instances_info.append(spec_info)
                    platform_data["instances"] = instances_info
                else:
                    # For dynamic platforms, show scaling configuration
                    platform_data["min_instances"] = platform.min_instances
                    platform_data["max_instances"] = platform.max_instances

                platforms_data.append(platform_data)
        return platforms_data

actor WebServ(listen_cap: net.TCPListenCap, port, director, log_handler: logging.Handler):
    logh = logging.Handler("WebServ")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    def _on_http_accept(server):
        server.cb_install(_on_http_server_request, _on_http_server_error)

    def _on_http_server_request(server, request, respond):
        _log.info("HTTP request received", {"method": request.method, "path": request.path})
        if request.path == "/api/v1/convert" and request.method == "POST":
            _log.info("Processing conversion request")
            try:
                body_str = request.body.decode()
                _log.debug("Request body", {"body": body_str})
                body_dict = json.decode(body_str)
                _log.debug("Parsed JSON", {"body_dict": str(body_dict)})

                # Parse the request using the from_json method
                convert_req = ConvertRequest.from_json(body_dict)
                _log.info("ConvertRequest created", {"input_format": convert_req.format, "output_format": convert_req.target_format, "platform": convert_req.platform})

                # Define callback for when conversion completes
                def on_conversion_done(result: str, success: bool):
                    _log.debug("Conversion completed, preparing HTTP response")
                    if success:
                        _log.info("Conversion successful", {"result_length": len(result)})

                        # Try to parse the result as JSON (base_config + config format)
                        try:
                            result_dict = json.decode(result)
                            if isinstance(result_dict, dict) and "base_config" in result_dict and "config" in result_dict:
                                # New format with before/after configs and diff
                                response = {
                                    "success": True,
                                    "base_config": result_dict["base_config"],
                                    "config": result_dict["config"],
                                    "platform": convert_req.platform,
                                    "platform_version": "1.0"
                                }
                                # Add diff field if it exists in result_dict
                                if "diff" in result_dict:
                                    response["diff"] = result_dict["diff"]
                                else:
                                    response["diff"] = ""
                            else:
                                # Fallback to old format
                                response = {
                                    "success": True,
                                    "output": result,
                                    "platform": convert_req.platform,
                                    "platform_version": "1.0"
                                }
                        except Exception:
                            # If JSON parsing fails, use old format
                            response = {
                                "success": True,
                                "output": result,
                                "platform": convert_req.platform,
                                "platform_version": "1.0"
                            }
                    else:
                        _log.error("Conversion failed", {"result": result})
                        response = {
                            "success": False,
                            "error": result,
                            "platform": convert_req.platform
                        }
                    response_str = json.encode(response)
                    _log.debug("Sending HTTP response", {"response_length": len(response_str)})
                    respond(200, {"Content-Type": "application/json"}, response_str)

                # Use Director's conversion logic with callback
                _log.debug("Calling Director.convert")
                director.convert(convert_req, on_conversion_done)
            except Exception as e:
                error_dict = {"success": False, "error": str(e)}
                error_str = json.encode(error_dict)
                respond(400, {"Content-Type": "application/json"}, error_str)
        # GET /api/v1/instances - List all running instances
        elif request.path == "/api/v1/instances" and request.method == "GET":
            # Get actual instances from director
            instances_data = director.get_instances()

            response = {
                "instances": instances_data,
                "total": len(instances_data)
            }
            respond(200, {"Content-Type": "application/json"}, json.encode(response))

        # GET /api/v1/platforms - List configured platforms
        elif request.path == "/api/v1/platforms" and request.method == "GET":
            # Get actual platforms from director
            platforms_data = director.get_platforms()

            response = {
                "platforms": platforms_data,
                "total": len(platforms_data)
            }
            respond(200, {"Content-Type": "application/json"}, json.encode(response))

        else:
            respond(404, {}, json.encode({"error": "Not found"}))

    def _on_http_server_error(server, error):
        pass

    server = http.Listener(listen_cap, "0.0.0.0", port, _on_http_accept)


def get_default_config() -> SystemConfig:
    return SystemConfig([
        # Juniper cRPD platform - dynamically managed containers
#        PlatformConfig(
#            name="crpd",
#            version="24.4R1.9",
#            container_image="ghcr.io/orchestron-orchestrator/respnet/crpd:24.4R1.9",
#            min_instances=1,
#            max_instances=3
#        ),
        # Local cRPD static instance
        PlatformConfig(
            name="crpd 24.4R1.9-local",
            platform="junos",
            instances=[
                InstanceSpec(
                    id="local-crpd",
                    host="127.0.0.1",
                    netconf_port=42830,
                    ssh_port=42022,
                    restconf_port=32774,
                    username="clab",
                    password="clab@123",
                    description="Local cRPD instance"
                )
            ]
        ),
        # Example platform with static instances (could be physical devices, VMs, etc.)
#        PlatformConfig(
#            name="junos",
#            version="21.4R1",
#            static_instances=[
#                InstanceSpec(
#                    instance_id="lab-router-1",
#                    host="192.168.1.10",
#                    netconf_port=830,
#                    ssh_port=22,
#                    username="admin",
#                    description="Lab router #1"
#                ),
#                InstanceSpec(
#                    instance_id="lab-router-2",
#                    host="192.168.1.11",
#                    netconf_port=830,
#                    ssh_port=22,
#                    username="admin",
#                    description="Lab router #2"
#                )
#            ]
#        )
    ])

actor main(env: Env):
    listen_cap = net.TCPListenCap(net.TCPCap(net.NetCap(env.cap)))
    proc_cap = process.ProcessCap(env.cap)
    port = 8080

    # Load configuration
    config = get_default_config()
    # Create logging handler
    log_handler = logging.Handler(None)
    log_handler.add_sink(logging.StdoutSink())
    log_handler.set_output_level(logging.TRACE)  # Set maximum debugging for SSH/NETCONF

    # Create logger for main
    logh = logging.Handler("main")
    logh.set_handler(log_handler)
    _log = logging.Logger(logh)

    _log.info("Loaded platform configurations", {"platform_count": len(config.platforms)})

    director = Director(env.cap, proc_cap, log_handler)
    director.set_config(config)
    webs = WebServ(listen_cap, port, director, log_handler)
    _log.info("NETCLICS started", {"port": port})
