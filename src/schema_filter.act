"""Schema filtering support for YANG module sets

This module provides pattern-based filtering for YANG schemas, allowing
users to select specific sets of modules (classic, unified-model, openconfig, etc.)
to avoid conflicts and reduce compilation overhead.
"""

import re

class ModuleSet:
    """Represents a set of YANG modules defined by include/exclude patterns"""

    name: str
    description: str
    include_patterns: list[str]
    exclude_patterns: list[str]

    def __init__(self, name: str, description: str, include_patterns: list[str]=[], exclude_patterns: list[str]=[]):
        self.name = name
        self.description = description
        self.include_patterns = include_patterns
        self.exclude_patterns = exclude_patterns

    def matches(self, module_name: str) -> bool:
        """Check if a module name matches this module set's patterns"""
        # First check if it matches any include pattern
        if len(self.include_patterns) == 0:
            matched = True
        else:
            matched = False
            for pattern in self.include_patterns:
                if re.match(pattern, module_name) is not None:
                    matched = True
                    break

        if not matched:
            return False

        # Then check it doesn't match any exclude pattern
        for pattern in self.exclude_patterns:
            if re.match(pattern, module_name) is not None:
                return False

        return True


# Define standard module sets
CISCO_XR_CLASSIC = ModuleSet(
    "cisco-xr-classic",
    "Cisco IOS XR Classic configuration models",
    include_patterns=["^Cisco-IOS-XR-", "^tailf-", "^cisco-semver", "^ietf-"],
    exclude_patterns=["^ietf-interfaces", "^Cisco-IOS-XR-um-", "^Cisco-IOS-XR-openconfig"]
)

CISCO_XR_UNIFIED_MODEL = ModuleSet(
    "cisco-xr-unified-model",
    "Cisco IOS XR Unified Model with base types",
    include_patterns=["^Cisco-IOS-XR-um-", "^Cisco-IOS-XR-types", "^Cisco-IOS-XR-.*-datatypes", "^ietf-", "^tailf-", "^cisco-semver"],
    exclude_patterns=["^ietf-interfaces"]
)

CISCO_XE_NATIVE = ModuleSet(
    "cisco-xe-native",
    """Cisco IOS XE "native" configuration model with dependencies""",
    include_patterns=["^Cisco-IOS-XE-", "^cisco-semver", "^ietf-inet-types", "^ietf-yang-types"]
)

OPENCONFIG = ModuleSet(
    "openconfig",
    "OpenConfig standard models",
    include_patterns=["^openconfig-"]
)

IETF = ModuleSet(
    "ietf",
    "IETF standard models",
    include_patterns=["^ietf-", "^iana-"]
)

ALL_MODULES = ModuleSet(
    "all",
    "All available models"
)

# Registry of all available module sets
MODULE_SETS = {
    "cisco-xr-classic": CISCO_XR_CLASSIC,
    "cisco-xr-unified-model": CISCO_XR_UNIFIED_MODEL,
    "cisco-xe-native": CISCO_XE_NATIVE,
    "openconfig": OPENCONFIG,
    "ietf": IETF,
    "all": ALL_MODULES
}


def should_include_module(module_name: str, module_set_names: list[str]) -> bool:
    """Check if a module should be included based on selected module sets"""
    # If no sets specified, include everything
    if len(module_set_names) == 0:
        return True

    # Check if module matches any of the selected sets
    for set_name in module_set_names:
        module_set = MODULE_SETS.get(set_name)
        if module_set is not None and module_set.matches(module_name):
            return True

    return False


def filter_schemas(
    schemas: list[(identifier: str, namespace: ?str, version: ?str, format: str)],
    module_set_names: list[str]
) -> list[(identifier: str, namespace: ?str, version: ?str, format: str)]:
    """Filter a list of schemas based on selected module sets"""
    if len(module_set_names) == 0:
        return schemas

    filtered = []
    for schema in schemas:
        if should_include_module(schema.identifier, module_set_names):
            filtered.append(schema)

    return filtered


def validate_module_sets(set_names: list[str]) -> list[str]:
    """Validate module set names and check for known incompatibilities"""
    warnings = []

    # Check all set names are valid
    for name in set_names:
        if name not in MODULE_SETS:
            warnings.append("Unknown module set: {name}")

    # Check for known incompatibilities
    if "cisco-xr-classic" in set_names and "cisco-xr-unified-model" in set_names:
        warnings.append("Warning: Cisco XR Classic and Cisco XR Unified Model may have conflicting definitions")

    if "cisco-xr-classic" in set_names and "openconfig" in set_names:
        warnings.append("Warning: Cisco XR Classic and OpenConfig may have overlapping namespaces for common features")

    if "cisco-xr-unified-model" in set_names and "openconfig" in set_names:
        warnings.append("Warning: Cisco XR Unified Model and OpenConfig may have overlapping namespaces")

    return warnings


def get_module_set_names() -> str:
    """Get a comma-separated string of available module set names for help text"""
    names = []
    for key in MODULE_SETS:
        names.append(key)
    return ", ".join(sorted(names))
