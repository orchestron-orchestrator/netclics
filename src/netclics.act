import http
import json
import net
import time
import process

actor ContainerManager(proc_cap: process.ProcessCap):
    """Manages Docker containers for network devices"""

    def start_container(platform: PlatformConfig, instance_id: str) -> str:
        """Start a Docker container for the given platform"""
        # Generate unique container name
        container_name = "netclics-%s-%s" % (platform.name.replace(" ", "-"), instance_id)

        # Build docker run command arguments
        # --name: container name
        # --rm: remove container when it stops
        # -p: publish ports (would map container ports to host ports)
        # Note: In production, we'd run in foreground to stop with our process
        # For now, just use a placeholder image since the actual startup is mocked
        # In a real implementation, we would handle the optional container_image properly
        docker_args = [
            "run",
            "--name", container_name,
            "--rm",
            "-d",  # Detached mode for now
            "placeholder-image"  # Temporary placeholder - not actually used since we don't run containers
        ]

        print("Starting container: docker %s" % " ".join(docker_args))

        # For now, just print the command we would run
        # In production, would execute: process.Process(proc_cap, "docker", docker_args, {})
        print("Would execute: docker %s" % " ".join(docker_args))

        # Schedule health check
        after 2: _check_container_health(container_name, platform)

        return container_name

    def _check_container_health(container_name: str, platform: PlatformConfig):
        """Check if container is healthy and get its network info"""
        # In reality, would run: docker inspect <container_name>
        # This would be done with:
        # inspect_proc = process.Process(proc_cap, "docker", ["inspect", container_name], {})
        # Then parse the JSON output to get:
        # - Container state (running, health status)
        # - IP address from NetworkSettings.IPAddress
        # - Port mappings from NetworkSettings.Ports

        print("Checking health of container %s" % container_name)
        # Would parse actual docker inspect output here

    def get_container_info(container_name: str) -> dict[str, str]:
        """Get container network information"""
        # In reality: docker inspect <container_name>
        # Returns mock data for now
        return {
            "ip": "172.17.0.10",
            "netconf_port": "32830",
            "ssh_port": "32822"
        }

    def stop_container(container_name: str):
        """Stop a Docker container"""
        # In reality, would run: docker stop <container_name>
        print("Stopping container: %s" % container_name)
        # Since we use --rm, container will be removed automatically

class DeviceInstance(object):
    def __init__(self, platform_name: str, platform: str,
                 container_id: str, ip_address: str,
                 netconf_port: int, ssh_port: int, instance_spec: ?InstanceSpec = None):
        self.platform_name = platform_name
        self.platform = platform
        self.container_id = container_id
        self.ip_address = ip_address
        self.netconf_port = netconf_port
        self.ssh_port = ssh_port
        self.instance_spec = instance_spec  # Set if this is a static instance
        self.state = "starting"  # starting, ready, busy, stopping, error
        self.current_request = None  # Currently processing request
        self.started_at = 0  # Timestamp when started
        self.last_used_at = 0  # Timestamp of last use
        
    def is_static_instance(self) -> bool:
        """Returns True if this is a static instance (not a dynamic container)"""
        instance_spec = self.instance_spec
        if instance_spec is not None:
            return True
        return False

class DeviceManager(object):
    """Manages device lifecycle and state transitions"""
    def __init__(self, config: SystemConfig, container_mgr: ContainerManager):
        self.config = config
        self.container_mgr = container_mgr
        self.instances = []
        self.pending_requests = []  # Requests waiting for a device
        self.next_instance_id = 1

    def initialize_min_instances(self):
        """Initialize specified instances and start minimum number of container instances for each platform"""
        for platform in self.config.platforms:
            # First, initialize any static instances
            self.initialize_static_instances(platform)
            
            # Then start minimum container instances if needed
            if not platform.uses_static_instances() and platform.min_instances > 0:
                current_count = self.count_instances(platform.name)
                to_start = platform.min_instances - current_count
                for i in range(to_start):
                    self.start_device(platform)
                    
    def initialize_static_instances(self, platform: PlatformConfig):
        """Initialize static instances for a platform"""
        for spec in platform.instances:
            device = DeviceInstance(
                platform_name=platform.name,
                platform=platform.platform,
                container_id=spec.id,
                ip_address=spec.host,
                netconf_port=spec.netconf_port,
                ssh_port=spec.ssh_port,
                instance_spec=spec
            )
            device.state = "ready"  # Specified instances are assumed to be ready
            self.instances.append(device)
            print("Initialized static instance: %s at %s:%d" % (spec.id, spec.host, spec.netconf_port))

    def count_instances(self, platform_name: str, state: ?str = None) -> int:
        """Count instances for a platform, optionally filtered by state"""
        count = 0
        for instance in self.instances:
            if instance.platform_name == platform_name:
                if state is None or instance.state == state:
                    count += 1
        return count

    def get_device_for_request(self, platform_name: str) -> ?DeviceInstance:
        """Get or create a device for a request"""
        # First, try to find a ready device (static instances or containers)
        for instance in self.instances:
            if instance.state == "ready" and instance.platform_name == platform_name:
                instance.state = "busy"
                return instance

        # Find the platform config
        platform_config = self.config.get_platform(platform_name)
        if platform_config is not None:
            # For platforms with static instances, we can't create new instances
            if platform_config.uses_static_instances():
                # All static instances are busy, return None to queue the request
                return None
                
            # For container platforms, check if we can start a new instance
            # Check if we have devices starting up
            starting_count = 0
            for instance in self.instances:
                if instance.state == "starting" and instance.platform_name == platform_name:
                    starting_count += 1

            # Check if we can start a new container instance
            total_count = self.count_instances(platform_config.name)
            if total_count < platform_config.max_instances:
                # Start a new device
                return self.start_device(platform_config)
            elif starting_count > 0:
                # We have devices starting, queue this request
                return None  # Caller should queue the request
            else:
                # All devices are busy and we're at max capacity
                return None
        else:
            return None

    def start_device(self, platform: PlatformConfig) -> ?DeviceInstance:
        """Start a new device instance (only for dynamically managed platforms)"""
        if platform.uses_static_instances():
            print("Error: Cannot start new instances for platform with static instances: %s" % platform.name)
            return None
            
        instance_id = str(self.next_instance_id)
        self.next_instance_id += 1

        # Create a placeholder device in starting state
        device = DeviceInstance(
            platform_name="dynamic-platform",  # Hardcoded for now
            platform="dynamic",  # Hardcoded for now
            container_id="starting-%s" % instance_id,
            ip_address="pending",
            netconf_port=830,  # Use default for now
            ssh_port=22  # Use default for now
        )
        device.state = "starting"
        self.instances.append(device)

        # Call the container manager to start the container
        container_name = self.container_mgr.start_container(platform, instance_id)

        # Update device with container info
        device.state = "ready"
        device.container_id = container_name
        device.ip_address = "172.17.0.%d" % (10 + int(instance_id))

        return device

    def release_device(self, device: DeviceInstance):
        """Release a device after use"""
        device.state = "ready"
        device.current_request = None

        # Check if we should shut down this device
        platform = self.config.get_platform(device.platform_name)
        if platform is not None:
            current_count = self.count_instances(device.platform_name)
            if current_count > platform.min_instances:
                # We have more than minimum, consider shutting down
                # For now, keep it running
                pass

class InstanceSpec(object):
    """Specification for a static instance (physical device, VM, or pre-existing container)"""
    def __init__(self, id: str, host: str, netconf_port: int = 830, 
                 ssh_port: int = 22, username: ?str = None, password: ?str = None, 
                 private_key_path: ?str = None, description: ?str = None):
        self.id = id
        self.host = host  # IP address or hostname
        self.netconf_port = netconf_port
        self.ssh_port = ssh_port
        self.username = username
        self.password = password
        self.private_key_path = private_key_path
        self.description = description

class PlatformConfig(object):
    def __init__(self, name: str, platform: str, container_image: ?str = None,
                 min_instances: int = 0, max_instances: int = 10,
                 startup_time_seconds: int = 60, idle_timeout_seconds: int = 300,
                 netconf_port: int = 830, ssh_port: int = 22, 
                 instances: ?list[InstanceSpec] = None):
        self.name = name
        self.platform = platform
        self.container_image = container_image  # Optional for physical devices
        self.min_instances = min_instances
        self.max_instances = max_instances
        self.startup_time_seconds = startup_time_seconds  # Expected container startup time
        self.idle_timeout_seconds = idle_timeout_seconds  # When to shut down idle containers
        self.netconf_port = netconf_port  # NETCONF port inside container
        self.ssh_port = ssh_port  # SSH/CLI port inside container
        self.instances = instances if instances is not None and len(instances) > 0 else []  # Static instances
        # Runtime state (managed by Director)
        self.active_instances = 0
        self.available_instances = 0
        
    def uses_static_instances(self) -> bool:
        """Returns True if this platform uses static instances rather than dynamic scaling"""
        return len(self.instances) > 0

class SystemConfig(object):
    def __init__(self, platforms: list[PlatformConfig]):
        self.platforms = platforms

    def get_platform(self, name: str) -> ?PlatformConfig:
        for p in self.platforms:
            if p.name == name:
                return p
        return None

class ConvertRequest(object):
    def __init__(self, input: str, format: str, target_format: str, platform: str, cb: ?action(str) -> None = None):
        self.input = input
        self.format = format
        self.target_format = target_format
        self.platform = platform
        self.platform_version = None  # For now, always None
        self.cb = cb  # Optional callback for async processing

    @staticmethod
    def from_json(data: dict[str, ?value]):
        # Get all required fields first
        if "input" not in data:
            raise ValueError("Missing required field: input")
        if "format" not in data:
            raise ValueError("Missing required field: format")
        if "target_format" not in data:
            raise ValueError("Missing required field: target_format")
        if "platform" not in data:
            raise ValueError("Missing required field: platform")

        input_val = data["input"]
        format_val = data["format"]
        target_format_val = data["target_format"]
        platform_val = data["platform"]

        # Type check all at once
        if isinstance(input_val, str) and isinstance(format_val, str) and isinstance(target_format_val, str) and isinstance(platform_val, str):
            return ConvertRequest(input_val, format_val, target_format_val, platform_val, None)
        else:
            raise ValueError("All fields must be strings")

actor Director(proc_cap: process.ProcessCap):
    var device_manager: ?DeviceManager = None

    def set_config(conf: SystemConfig):
        container_mgr = ContainerManager(proc_cap)
        dm = DeviceManager(conf, container_mgr)
        dm.initialize_min_instances()
        device_manager = dm
        print("Director initialized, starting %d device instances" % len(dm.instances))

    def process_request(request: ConvertRequest):
        """Process a conversion request"""
        dm = device_manager
        if dm is not None:
            device = dm.get_device_for_request(request.platform)
            if device is not None:
                print("Processing request on device %s at %s" % (device.container_id, device.ip_address))
                device.current_request = request

                # Mock processing
                # In reality, this would connect to the device and run the conversion
                if request.format == "cli" and request.target_format == "netconf":
                    output = "<rpc-reply><configuration><!-- Converted from CLI --></configuration></rpc-reply>"
                else:
                    output = "! Converted from NETCONF\nconfigure\n! Configuration here\ncommit"

                # Release the device
                dm.release_device(device)
            else:
                print("No device available for %s" % request.platform)
                # In real implementation, queue the request

            # Store result for now
            # In real implementation, would call callback or respond to HTTP
        else:
            print("Error: Director not initialized")

    def cli2xml(conf: str, cb):
        raise NotImplementedError()

    def xml2cli(conf: str):
        raise NotImplementedError()
        
    def get_instances() -> list[dict[str, ?value]]:
        """Get list of all instances for API response"""
        instances_data: list[dict[str, ?value]] = []
        dm = device_manager
        if dm is not None:
            for instance in dm.instances:
                instance_data = {
                    "platform_name": instance.platform_name,
                    "platform": instance.platform,
                    "instance_id": instance.container_id,
                    "ip_address": instance.ip_address,
                    "state": instance.state,
                    "netconf_port": instance.netconf_port,
                    "ssh_port": instance.ssh_port,
                    "instance_type": "static" if instance.is_static_instance() else "container"
                }
                instance_spec = instance.instance_spec
                if instance_spec is not None:
                    desc = instance_spec.description
                    if desc is not None:
                        instance_data["description"] = desc
                instances_data.append(instance_data)
        return instances_data

    def get_platforms() -> list[dict[str, ?value]]:
        """Get list of all configured platforms for API response"""
        platforms_data: list[dict[str, ?value]] = []
        dm = device_manager
        if dm is not None:
            for platform in dm.config.platforms:
                # Count current instances
                total_instances = 0
                available_instances = 0
                for instance in dm.instances:
                    if instance.platform_name == platform.name:
                        total_instances += 1
                        if instance.state == "ready":
                            available_instances += 1

                platform_data = {
                    "name": platform.name,
                    "platform": platform.platform,
                    "scaling_type": "static" if platform.uses_static_instances() else "dynamic",
                    "total_instances": total_instances,
                    "available_instances": available_instances
                }

                # Add static instances info if applicable
                if platform.uses_static_instances():
                    instances_info = []
                    for spec in platform.instances:
                        instance_info = {
                            "id": spec.id,
                            "host": spec.host,
                            "netconf_port": spec.netconf_port,
                            "ssh_port": spec.ssh_port
                        }
                        desc = spec.description
                        if desc is not None:
                            instance_info["description"] = desc
                        instances_info.append(instance_info)
                    platform_data["instances"] = instances_info
                else:
                    # For dynamic platforms, show scaling configuration
                    platform_data["min_instances"] = platform.min_instances
                    platform_data["max_instances"] = platform.max_instances

                platforms_data.append(platform_data)
        return platforms_data

actor WebServ(listen_cap: net.TCPListenCap, port, director):

    def _on_http_accept(server):
        server.cb_install(_on_http_server_request, _on_http_server_error)

    def _on_http_server_request(server, request, respond):
        if request.path == "/api/v1/convert" and request.method == "POST":
            try:
                body_str = request.body.decode()
                body_dict = json.decode(body_str)

                # Parse the request using the from_json method
                convert_req = ConvertRequest.from_json(body_dict)

                # Mock conversion based on format
                if convert_req.format == "cli" and convert_req.target_format == "netconf":
                    output = "<rpc-reply><configuration><!-- Converted from CLI --></configuration></rpc-reply>"
                else:
                    output = "! Converted from NETCONF\nconfigure\n! Configuration here\ncommit"

                response = {
                    "success": True,
                    "output": output,
                    "platform": convert_req.platform,
                    "platform_version": "mock-1.0"
                }
                response_str = json.encode(response)
                respond(200, {"Content-Type": "application/json"}, response_str)
            except Exception as e:
                error_dict = {"success": False, "error": str(e)}
                error_str = json.encode(error_dict)
                respond(400, {"Content-Type": "application/json"}, error_str)
        # GET /api/v1/instances - List all running instances
        elif request.path == "/api/v1/instances" and request.method == "GET":
            # Get actual instances from director
            instances_data = director.get_instances()
            
            response = {
                "instances": instances_data,
                "total": len(instances_data)
            }
            respond(200, {"Content-Type": "application/json"}, json.encode(response))

        # GET /api/v1/platforms - List configured platforms
        elif request.path == "/api/v1/platforms" and request.method == "GET":
            # Get actual platforms from director
            platforms_data = director.get_platforms()
            
            response = {
                "platforms": platforms_data,
                "total": len(platforms_data)
            }
            respond(200, {"Content-Type": "application/json"}, json.encode(response))

        else:
            respond(404, {}, json.encode({"error": "Not found"}))

    def _on_http_server_error(server, error):
        pass

    server = http.Listener(listen_cap, "0.0.0.0", port, _on_http_accept)


def get_default_config() -> SystemConfig:
    return SystemConfig([
        # Juniper cRPD platform - dynamically managed containers
#        PlatformConfig(
#            name="crpd",
#            version="24.4R1.9",
#            container_image="ghcr.io/orchestron-orchestrator/respnet/crpd:24.4R1.9",
#            min_instances=1,
#            max_instances=3
#        ),
        # Local cRPD static instance
        PlatformConfig(
            name="crpd 24.4R1.9-local",
            platform="junos",
            instances=[
                InstanceSpec(
                    id="local-crpd",
                    host="127.0.0.1",
                    netconf_port=32773,
                    ssh_port=32772,
                    username="admin",
                    password="admin",
                    description="Local cRPD instance"
                )
            ]
        ),
        # Example platform with static instances (could be physical devices, VMs, etc.)
#        PlatformConfig(
#            name="junos",
#            version="21.4R1",
#            static_instances=[
#                InstanceSpec(
#                    instance_id="lab-router-1",
#                    host="192.168.1.10",
#                    netconf_port=830,
#                    ssh_port=22,
#                    username="admin",
#                    description="Lab router #1"
#                ),
#                InstanceSpec(
#                    instance_id="lab-router-2",
#                    host="192.168.1.11",
#                    netconf_port=830,
#                    ssh_port=22,
#                    username="admin",
#                    description="Lab router #2"
#                )
#            ]
#        )
    ])

actor main(env: Env):
    listen_cap = net.TCPListenCap(net.TCPCap(net.NetCap(env.cap)))
    proc_cap = process.ProcessCap(env.cap)
    port = 8080

    # Load configuration
    config = get_default_config()
    print("Loaded %d platform configurations" % len(config.platforms))

    director = Director(proc_cap)
    director.set_config(config)
    webs = WebServ(listen_cap, port, director)
    print("NETCLICS started on port %d" % port)
